#!/usr/bin/env node

// Complete Futarchy Management Interface
// Automatically discovers pools, manages positions, and handles approvals

import { DataLayer } from '../DataLayer.js';
import { createPoolDiscoveryFetcher } from '../fetchers/PoolDiscoveryFetcher.js';
import { createProposalFetcher } from '../fetchers/ProposalFetcher.js';
import { ViemExecutor } from '../executors/ViemExecutor.js';
import { FutarchyCartridge } from '../executors/FutarchyCartridge.js';
import { createPublicClient, createWalletClient, http, formatEther, parseEther } from 'viem';
import { privateKeyToAccount } from 'viem/accounts';
import { gnosis } from 'viem/chains';
import inquirer from 'inquirer';
import chalk from 'chalk';
import ora from 'ora';
import boxen from 'boxen';
import dotenv from 'dotenv';

dotenv.config();

// Constants
const ROUTER_ADDRESS = '0x7495a583ba85875d59407781b4958ED6e0E1228f';
const CONDITIONAL_TOKENS = '0xCeAfDD6bc0bEF976fdCd1112955828E00543c0Ce';

class FutarchyManager {
    constructor() {
        this.dataLayer = new DataLayer();
        this.proposal = null;
        this.pools = null;
        this.tokens = null;
        this.prices = null;
        this.balances = {};
        
        // Initialize viem clients
        if (process.env.PRIVATE_KEY) {
            // Ensure private key has 0x prefix
            const privateKey = process.env.PRIVATE_KEY.startsWith('0x') 
                ? process.env.PRIVATE_KEY 
                : `0x${process.env.PRIVATE_KEY}`;
            this.account = privateKeyToAccount(privateKey);
            this.publicClient = createPublicClient({
                chain: gnosis,
                transport: http(process.env.RPC_URL || 'https://rpc.gnosischain.com')
            });
            this.walletClient = createWalletClient({
                account: this.account,
                chain: gnosis,
                transport: http(process.env.RPC_URL || 'https://rpc.gnosischain.com')
            });
            this.isConnected = true;
        } else {
            this.publicClient = createPublicClient({
                chain: gnosis,
                transport: http(process.env.RPC_URL || 'https://rpc.gnosischain.com')
            });
            this.isConnected = false;
        }
        
        // Register fetchers
        this.poolFetcher = createPoolDiscoveryFetcher();
        this.proposalFetcher = createProposalFetcher();
        this.dataLayer.registerFetcher(this.poolFetcher);
        this.dataLayer.registerFetcher(this.proposalFetcher);
        
        // Register executor if connected
        if (this.isConnected) {
            this.executor = new ViemExecutor({
                publicClient: this.publicClient,
                walletClient: this.walletClient,
                account: this.account
            });
            
            // Add cartridge for enhanced operations
            const cartridge = new FutarchyCartridge();
            this.executor.registerCartridge(cartridge);
            
            this.dataLayer.registerExecutor(this.executor);
        }
    }
    
    async initialize() {
        console.log(chalk.cyan.bold('\nðŸš€ Futarchy Complete Manager\n'));
        
        if (this.isConnected) {
            const balance = await this.publicClient.getBalance({ 
                address: this.account.address 
            });
            
            console.log(boxen(
                `âœ… Connected to Gnosis Chain\n` +
                `ðŸ‘› Account: ${chalk.green(this.account.address)}\n` +
                `ðŸ’° Balance: ${chalk.yellow(formatEther(balance))} xDAI`,
                {
                    padding: 1,
                    borderStyle: 'round',
                    borderColor: 'green'
                }
            ));
        } else {
            console.log(chalk.yellow('âš ï¸  Read-only mode (no private key provided)'));
        }
    }
    
    async selectProposal() {
        const { proposalAddress } = await inquirer.prompt([
            {
                type: 'input',
                name: 'proposalAddress',
                message: 'Enter Futarchy proposal address:',
                default: '0xA94aB35282118f38b0b4FF89dDA7A5c04aD49371',
                validate: (input) => {
                    return /^0x[a-fA-F0-9]{40}$/.test(input) || 'Please enter a valid address';
                }
            }
        ]);
        
        const spinner = ora('Loading proposal data...').start();
        
        try {
            // Fetch proposal details
            const [details, status, tokens, wrapped] = await Promise.all([
                this.dataLayer.fetch('proposal.details', { proposalAddress }),
                this.dataLayer.fetch('proposal.status', { proposalAddress }),
                this.dataLayer.fetch('proposal.tokens', { proposalAddress }),
                this.dataLayer.fetch('proposal.wrapped', { proposalAddress })
            ]);
            
            spinner.succeed('Proposal loaded');
            
            this.proposal = {
                address: proposalAddress,
                details: details.data,
                status: status.data,
                tokens: tokens.data,
                wrapped: wrapped.data
            };
            
            // Display proposal info
            console.log(boxen(
                `ðŸ“ ${chalk.cyan.bold(details.data.marketName)}\n` +
                `â“ ${details.data.encodedQuestion}\n` +
                `ðŸ“Š Status: ${this.getStatusColor(status.data.status)}\n` +
                `${status.data.currentAnswer ? `âœ… Current Answer: ${chalk.bold(status.data.currentAnswer)}` : ''}`,
                {
                    padding: 1,
                    borderStyle: 'round',
                    borderColor: 'magenta',
                    title: 'ðŸ›ï¸ Proposal Information'
                }
            ));
            
        } catch (error) {
            spinner.fail('Failed to load proposal');
            throw error;
        }
    }
    
    async discoverPools() {
        const spinner = ora('Discovering pools...').start();
        
        try {
            // Discover pools
            const discovery = await this.dataLayer.fetch('pools.discover', { 
                proposalAddress: this.proposal.address 
            });
            
            // Get prices
            const prices = await this.dataLayer.fetch('pools.prices', { 
                proposalAddress: this.proposal.address 
            });
            
            spinner.succeed(`Found ${discovery.data.totalPools} pools`);
            
            this.pools = discovery.data;
            this.prices = prices.data.prices;
            // Tokens are already addresses from discovery.data.tokens
            this.tokens = discovery.data.tokens;
            
            // Display all 6 pool prices correctly
            console.log('\n' + chalk.cyan.bold('ðŸ’± All Pool Prices:'));
            
            // Conditional Pools (how much currency to buy company token)
            console.log(chalk.yellow('\nConditional Pools:'));
            if (this.prices['YES_COMPANY/YES_CURRENCY']) {
                const pool = this.prices['YES_COMPANY/YES_CURRENCY'];
                // Determine which token is which and show price accordingly
                const yesCompanyIsToken0 = pool.token0.toLowerCase() === this.tokens.yesCompany.toLowerCase();
                const price = yesCompanyIsToken0 ? pool.price : pool.priceInverse;
                console.log(chalk.gray('  YES_COMPANY/YES_CURRENCY:'), `1 YES_COMPANY = ${price.toFixed(4)} YES_CURRENCY`);
            }
            if (this.prices['NO_COMPANY/NO_CURRENCY']) {
                const pool = this.prices['NO_COMPANY/NO_CURRENCY'];
                const noCompanyIsToken0 = pool.token0.toLowerCase() === this.tokens.noCompany.toLowerCase();
                const price = noCompanyIsToken0 ? pool.price : pool.priceInverse;
                console.log(chalk.gray('  NO_COMPANY/NO_CURRENCY:'), `1 NO_COMPANY = ${price.toFixed(4)} NO_CURRENCY`);
            }
            
            // Prediction Pools (how much sDAI to buy each token)
            console.log(chalk.yellow('\nPrediction Pools vs sDAI:'));
            
            // YES_COMPANY/sDAI
            if (this.prices['YES_COMPANY/BASE_CURRENCY']) {
                const pool = this.prices['YES_COMPANY/BASE_CURRENCY'];
                const yesCompanyIsToken0 = pool.token0.toLowerCase() === this.tokens.yesCompany.toLowerCase();
                const price = yesCompanyIsToken0 ? pool.price : pool.priceInverse;
                console.log(chalk.gray('  YES_COMPANY/sDAI:'), chalk.green(`1 YES_COMPANY = ${price.toFixed(6)} sDAI`));
            }
            
            // NO_COMPANY/sDAI
            if (this.prices['NO_COMPANY/BASE_CURRENCY']) {
                const pool = this.prices['NO_COMPANY/BASE_CURRENCY'];
                const noCompanyIsToken0 = pool.token0.toLowerCase() === this.tokens.noCompany.toLowerCase();
                const price = noCompanyIsToken0 ? pool.price : pool.priceInverse;
                console.log(chalk.gray('  NO_COMPANY/sDAI:'), chalk.red(`1 NO_COMPANY = ${price.toFixed(6)} sDAI`));
            }
            
            // YES_CURRENCY/sDAI
            if (this.prices['YES_CURRENCY/BASE_CURRENCY']) {
                const pool = this.prices['YES_CURRENCY/BASE_CURRENCY'];
                const yesCurrencyIsToken0 = pool.token0.toLowerCase() === this.tokens.yesCurrency.toLowerCase();
                const price = yesCurrencyIsToken0 ? pool.price : pool.priceInverse;
                console.log(chalk.gray('  YES_CURRENCY/sDAI:'), chalk.green(`1 YES_CURRENCY = ${price.toFixed(6)} sDAI`));
            }
            
            // NO_CURRENCY/sDAI
            if (this.prices['NO_CURRENCY/BASE_CURRENCY']) {
                const pool = this.prices['NO_CURRENCY/BASE_CURRENCY'];
                const noCurrencyIsToken0 = pool.token0.toLowerCase() === this.tokens.noCurrency.toLowerCase();
                const price = noCurrencyIsToken0 ? pool.price : pool.priceInverse;
                console.log(chalk.gray('  NO_CURRENCY/sDAI:'), chalk.red(`1 NO_CURRENCY = ${price.toFixed(6)} sDAI`));
            }
            
            // Display implied probabilities
            if (prices.data.impliedProbability) {
                const prob = prices.data.impliedProbability;
                
                // Use prediction currency method if available (most accurate)
                if (prob.fromPredictionCurrency) {
                    console.log('\n' + chalk.cyan('ðŸ“Š Implied Probabilities:'));
                    
                    // Show direct prices as probabilities
                    const yesProb = (prob.fromPredictionCurrency.yes * 100).toFixed(1);
                    const noProb = (prob.fromPredictionCurrency.no * 100).toFixed(1);
                    console.log(chalk.gray('  Direct prices:'), 
                        chalk.green(`YES ${yesProb}%`), '/', 
                        chalk.red(`NO ${noProb}%`));
                    
                    // Show normalized if significantly different from 1.0
                    if (Math.abs(prob.fromPredictionCurrency.total - 1.0) > 0.1) {
                        const yesNorm = (prob.fromPredictionCurrency.yesNormalized * 100).toFixed(1);
                        const noNorm = (prob.fromPredictionCurrency.noNormalized * 100).toFixed(1);
                        console.log(chalk.gray('  Normalized:'), 
                            chalk.green(`YES ${yesNorm}%`), '/', 
                            chalk.red(`NO ${noNorm}%`));
                    }
                }
                // Fallback to company pools
                else if (prob.fromPredictionCompany) {
                    console.log('\n' + chalk.cyan('ðŸ“Š Implied Probabilities:'));
                    const yesProb = (prob.fromPredictionCompany.yes * 100).toFixed(1);
                    const noProb = (prob.fromPredictionCompany.no * 100).toFixed(1);
                    console.log(chalk.gray('  Direct:'), 
                        chalk.green(`YES ${yesProb}%`), '/', 
                        chalk.red(`NO ${noProb}%`));
                }
            }
            
        } catch (error) {
            spinner.fail('Failed to discover pools');
            throw error;
        }
    }
    
    async fetchBalances() {
        if (!this.isConnected) return;
        
        const spinner = ora('Fetching balances...').start();
        
        try {
            // Get collateral token symbols
            const [companySymbol, currencySymbol] = await Promise.all([
                this.publicClient.readContract({
                    address: this.tokens.companyToken,
                    abi: [{
                        name: 'symbol',
                        type: 'function',
                        stateMutability: 'view',
                        inputs: [],
                        outputs: [{ name: '', type: 'string' }]
                    }],
                    functionName: 'symbol'
                }).catch(() => 'COMPANY'),
                this.publicClient.readContract({
                    address: this.tokens.currencyToken,
                    abi: [{
                        name: 'symbol',
                        type: 'function',
                        stateMutability: 'view',
                        inputs: [],
                        outputs: [{ name: '', type: 'string' }]
                    }],
                    functionName: 'symbol'
                }).catch(() => 'CURRENCY')
            ]);
            
            // Get collateral token balances
            const [companyBalance, currencyBalance] = await Promise.all([
                this.publicClient.readContract({
                    address: this.tokens.companyToken,
                    abi: [{
                        name: 'balanceOf',
                        type: 'function',
                        stateMutability: 'view',
                        inputs: [{ name: 'account', type: 'address' }],
                        outputs: [{ name: '', type: 'uint256' }]
                    }],
                    functionName: 'balanceOf',
                    args: [this.account.address]
                }),
                this.publicClient.readContract({
                    address: this.tokens.currencyToken,
                    abi: [{
                        name: 'balanceOf',
                        type: 'function',
                        stateMutability: 'view',
                        inputs: [{ name: 'account', type: 'address' }],
                        outputs: [{ name: '', type: 'uint256' }]
                    }],
                    functionName: 'balanceOf',
                    args: [this.account.address]
                })
            ]);
            
            // Get wrapped token balances
            const balancePromises = this.proposal.wrapped.wrappedOutcomes.map(async (outcome) => {
                const balance = await this.publicClient.readContract({
                    address: outcome.wrapped1155,
                    abi: [{
                        name: 'balanceOf',
                        type: 'function',
                        stateMutability: 'view',
                        inputs: [{ name: 'account', type: 'address' }],
                        outputs: [{ name: '', type: 'uint256' }]
                    }],
                    functionName: 'balanceOf',
                    args: [this.account.address]
                }).catch(() => 0n);
                
                return { label: outcome.label, balance };
            });
            
            const wrappedBalances = await Promise.all(balancePromises);
            
            spinner.succeed('Balances fetched');
            
            // Store balances
            this.balances.company = companyBalance;
            this.balances.currency = currencyBalance;
            wrappedBalances.forEach(({ label, balance }) => {
                this.balances[label] = balance;
            });
            
            // Display balances
            console.log('\n' + chalk.cyan.bold('ðŸ’° Your Balances:'));
            
            // Show collateral tokens
            console.log(chalk.blue('Collateral Tokens:'));
            console.log(chalk.gray(`  ${companySymbol}:`), chalk.yellow(formatEther(companyBalance)));
            console.log(chalk.gray(`  ${currencySymbol}:`), chalk.yellow(formatEther(currencyBalance)));
            
            // Show conditional tokens
            const hasConditionalTokens = wrappedBalances.some(({ balance }) => balance > 0n);
            if (hasConditionalTokens) {
                console.log(chalk.blue('\nConditional Tokens:'));
                wrappedBalances.forEach(({ label, balance }) => {
                    if (balance > 0n) {
                        console.log(chalk.gray(`  ${label}:`), chalk.yellow(formatEther(balance)));
                    }
                });
            }
            
        } catch (error) {
            spinner.fail('Failed to fetch balances');
        }
    }
    
    async splitPosition() {
        if (!this.isConnected) {
            console.log(chalk.red('âŒ Wallet not connected'));
            return;
        }
        
        const spinner = ora('Fetching collateral token info...').start();
        
        try {
            // Get collateral token symbols and balances
            const [companySymbol, currencySymbol, companyBalance, currencyBalance] = await Promise.all([
                this.publicClient.readContract({
                    address: this.tokens.companyToken,
                    abi: [{
                        name: 'symbol',
                        type: 'function',
                        stateMutability: 'view',
                        inputs: [],
                        outputs: [{ name: '', type: 'string' }]
                    }],
                    functionName: 'symbol'
                }).catch(() => 'COMPANY'),
                this.publicClient.readContract({
                    address: this.tokens.currencyToken,
                    abi: [{
                        name: 'symbol',
                        type: 'function',
                        stateMutability: 'view',
                        inputs: [],
                        outputs: [{ name: '', type: 'string' }]
                    }],
                    functionName: 'symbol'
                }).catch(() => 'CURRENCY'),
                this.publicClient.readContract({
                    address: this.tokens.companyToken,
                    abi: [{
                        name: 'balanceOf',
                        type: 'function',
                        stateMutability: 'view',
                        inputs: [{ name: 'account', type: 'address' }],
                        outputs: [{ name: '', type: 'uint256' }]
                    }],
                    functionName: 'balanceOf',
                    args: [this.account.address]
                }).catch(() => 0n),
                this.publicClient.readContract({
                    address: this.tokens.currencyToken,
                    abi: [{
                        name: 'balanceOf',
                        type: 'function',
                        stateMutability: 'view',
                        inputs: [{ name: 'account', type: 'address' }],
                        outputs: [{ name: '', type: 'uint256' }]
                    }],
                    functionName: 'balanceOf',
                    args: [this.account.address]
                }).catch(() => 0n)
            ]);
            
            spinner.stop();
            
            // Show available collateral tokens
            console.log(chalk.cyan('\nðŸ’° Available Collateral Tokens:'));
            console.log(chalk.gray(`  1. ${companySymbol}:`), chalk.yellow(formatEther(companyBalance)), chalk.gray(`(${this.tokens.companyToken.slice(0, 8)}...)`));
            console.log(chalk.gray(`  2. ${currencySymbol}:`), chalk.yellow(formatEther(currencyBalance)), chalk.gray(`(${this.tokens.currencyToken.slice(0, 8)}...)`));
            
            const { collateralChoice, amount } = await inquirer.prompt([
                {
                    type: 'list',
                    name: 'collateralChoice',
                    message: 'Which collateral token to split?',
                    choices: [
                        { name: `${companySymbol} (Balance: ${formatEther(companyBalance)})`, value: 'company' },
                        { name: `${currencySymbol} (Balance: ${formatEther(currencyBalance)})`, value: 'currency' }
                    ]
                },
                {
                    type: 'input',
                    name: 'amount',
                    message: (answers) => {
                        const token = answers.collateralChoice === 'company' ? companySymbol : currencySymbol;
                        const balance = answers.collateralChoice === 'company' ? companyBalance : currencyBalance;
                        return `Amount of ${token} to split into YES/NO tokens (max: ${formatEther(balance)}):`;
                    },
                    default: '10',
                    validate: (input, answers) => {
                        const num = parseFloat(input);
                        if (num <= 0) return 'Please enter a positive amount';
                        const maxBalance = answers.collateralChoice === 'company' ? companyBalance : currencyBalance;
                        if (parseEther(input) > maxBalance) return 'Amount exceeds balance';
                        return true;
                    }
                }
            ]);
            
            const splitSpinner = ora('Splitting position...').start();
            
            // Determine which collateral to use
            const isCompanyCollateral = collateralChoice === 'company';
            const collateralToken = isCompanyCollateral ? this.tokens.companyToken : this.tokens.currencyToken;
            const collateralSymbol = isCompanyCollateral ? companySymbol : currencySymbol;
            
            // Get YES/NO token addresses we'll receive (from wrapped outcomes)
            const yesLabel = isCompanyCollateral ? 'YES_COMPANY' : 'YES_CURRENCY';
            const noLabel = isCompanyCollateral ? 'NO_COMPANY' : 'NO_CURRENCY';
            const yesOutcome = this.proposal.wrapped.wrappedOutcomes.find(o => o.label === yesLabel);
            const noOutcome = this.proposal.wrapped.wrappedOutcomes.find(o => o.label === noLabel);
            const yesToken = yesOutcome ? yesOutcome.wrapped1155 : this.tokens[isCompanyCollateral ? 'yesCompany' : 'yesCurrency'];
            const noToken = noOutcome ? noOutcome.wrapped1155 : this.tokens[isCompanyCollateral ? 'noCompany' : 'noCurrency'];
            
            // Get balances before split
            splitSpinner.text = 'Checking balances before split...';
            const [yesBalanceBefore, noBalanceBefore] = await Promise.all([
                this.publicClient.readContract({
                    address: yesToken,
                    abi: [{
                        name: 'balanceOf',
                        type: 'function',
                        stateMutability: 'view',
                        inputs: [{ name: 'account', type: 'address' }],
                        outputs: [{ name: '', type: 'uint256' }]
                    }],
                    functionName: 'balanceOf',
                    args: [this.account.address]
                }).catch(() => 0n),
                this.publicClient.readContract({
                    address: noToken,
                    abi: [{
                        name: 'balanceOf',
                        type: 'function',
                        stateMutability: 'view',
                        inputs: [{ name: 'account', type: 'address' }],
                        outputs: [{ name: '', type: 'uint256' }]
                    }],
                    functionName: 'balanceOf',
                    args: [this.account.address]
                }).catch(() => 0n)
            ]);
            
            splitSpinner.stop();
            console.log(chalk.cyan('\nðŸ“Š Balances Before Split:'));
            if (isCompanyCollateral) {
                console.log(chalk.gray(`  YES_COMPANY: ${formatEther(yesBalanceBefore)}`));
                console.log(chalk.gray(`  NO_COMPANY: ${formatEther(noBalanceBefore)}`));
            } else {
                console.log(chalk.gray(`  YES_CURRENCY: ${formatEther(yesBalanceBefore)}`));
                console.log(chalk.gray(`  NO_CURRENCY: ${formatEther(noBalanceBefore)}`));
            }
            
            splitSpinner.start('Splitting position...');
            
            // Check approval first
            const amountWei = parseEther(amount);
            await this.ensureApproval(collateralToken, ROUTER_ADDRESS, amountWei);
            
            // Execute split
            console.log('Executing split with params:', {
                proposal: this.proposal.address,
                amount: amountWei.toString(),
                collateralToken: collateralToken
            });
            
            for await (const status of this.dataLayer.execute('futarchy.splitPosition', {
                proposal: this.proposal.address,
                amount: amountWei,
                collateralToken: collateralToken
            })) {
                splitSpinner.text = status.message;
                
                if (status.status === 'success') {
                    splitSpinner.succeed(`Successfully split ${amount} ${collateralSymbol} into YES/NO tokens!`);
                    console.log(chalk.green('âœ… Transaction:'), status.data.transactionHash);
                    
                    // Get balances after split
                    const [yesBalanceAfter, noBalanceAfter] = await Promise.all([
                        this.publicClient.readContract({
                            address: yesToken,
                            abi: [{
                                name: 'balanceOf',
                                type: 'function',
                                stateMutability: 'view',
                                inputs: [{ name: 'account', type: 'address' }],
                                outputs: [{ name: '', type: 'uint256' }]
                            }],
                            functionName: 'balanceOf',
                            args: [this.account.address]
                        }),
                        this.publicClient.readContract({
                            address: noToken,
                            abi: [{
                                name: 'balanceOf',
                                type: 'function',
                                stateMutability: 'view',
                                inputs: [{ name: 'account', type: 'address' }],
                                outputs: [{ name: '', type: 'uint256' }]
                            }],
                            functionName: 'balanceOf',
                            args: [this.account.address]
                        })
                    ]);
                    
                    // Show balances after split
                    console.log(chalk.cyan('\nðŸ“Š Balances After Split:'));
                    if (isCompanyCollateral) {
                        console.log(chalk.gray(`  YES_COMPANY: ${formatEther(yesBalanceAfter)}`), chalk.green(`(+${formatEther(yesBalanceAfter - yesBalanceBefore)})`));
                        console.log(chalk.gray(`  NO_COMPANY: ${formatEther(noBalanceAfter)}`), chalk.green(`(+${formatEther(noBalanceAfter - noBalanceBefore)})`));
                    } else {
                        console.log(chalk.gray(`  YES_CURRENCY: ${formatEther(yesBalanceAfter)}`), chalk.green(`(+${formatEther(yesBalanceAfter - yesBalanceBefore)})`));
                        console.log(chalk.gray(`  NO_CURRENCY: ${formatEther(noBalanceAfter)}`), chalk.green(`(+${formatEther(noBalanceAfter - noBalanceBefore)})`));
                    }
                    
                    // Refresh all balances
                    await this.fetchBalances();
                }
            }
        } catch (error) {
            spinner.fail(`Failed to split: ${error.message}`);
        }
    }
    
    async redeemPosition() {
        if (!this.isConnected) {
            console.log(chalk.red('âŒ Wallet not connected'));
            return;
        }
        
        // Check if proposal is finalized
        if (!this.proposal.status.isFinalized) {
            console.log(chalk.yellow('âš ï¸  Proposal not yet finalized. Cannot redeem.'));
            return;
        }
        
        const spinner = ora('Checking redeemable positions...').start();
        
        try {
            // Determine winning outcome
            const winningOutcome = this.proposal.status.currentAnswer;
            const isYes = winningOutcome === 'YES';
            
            // Check winning token balances
            const winningTokens = isYes ? 
                ['YES_COMPANY', 'YES_CURRENCY'] : 
                ['NO_COMPANY', 'NO_CURRENCY'];
            
            const redeemableTokens = winningTokens.filter(token => 
                this.balances[token] && this.balances[token] > 0n
            );
            
            if (redeemableTokens.length === 0) {
                spinner.fail('No winning tokens to redeem');
                return;
            }
            
            spinner.succeed(`Found ${redeemableTokens.length} redeemable positions`);
            
            const { confirmRedeem } = await inquirer.prompt([
                {
                    type: 'confirm',
                    name: 'confirmRedeem',
                    message: `Redeem ${redeemableTokens.join(', ')} tokens?`,
                    default: true
                }
            ]);
            
            if (!confirmRedeem) return;
            
            const redeemSpinner = ora('Redeeming positions...').start();
            
            for await (const status of this.dataLayer.execute('futarchy.redeemPosition', {
                proposalAddress: this.proposal.address
            })) {
                redeemSpinner.text = status.message;
                
                if (status.status === 'success') {
                    redeemSpinner.succeed('Positions redeemed successfully!');
                    console.log(chalk.green('âœ… Transaction:'), status.data.transactionHash);
                    
                    // Refresh balances
                    await this.fetchBalances();
                }
            }
            
        } catch (error) {
            spinner.fail(`Failed to redeem: ${error.message}`);
        }
    }
    
    async mergePosition() {
        if (!this.isConnected) {
            console.log(chalk.red('âŒ Wallet not connected'));
            return;
        }
        
        const spinner = ora('Fetching conditional token balances...').start();
        
        try {
            // Get all wrapped token balances to find mergeable pairs
            const balances = await Promise.all(
                this.proposal.wrapped.wrappedOutcomes.map(async (outcome) => {
                    const balance = await this.publicClient.readContract({
                        address: outcome.wrapped1155,
                        abi: [{
                            name: 'balanceOf',
                            type: 'function',
                            stateMutability: 'view',
                            inputs: [{ name: 'account', type: 'address' }],
                            outputs: [{ name: '', type: 'uint256' }]
                        }],
                        functionName: 'balanceOf',
                        args: [this.account.address]
                    }).catch(() => 0n);
                    
                    return { 
                        label: outcome.label, 
                        address: outcome.wrapped1155,
                        balance 
                    };
                })
            );
            
            // Find YES/NO pairs for company tokens
            const yesCompany = balances.find(b => b.label === 'YES_COMPANY');
            const noCompany = balances.find(b => b.label === 'NO_COMPANY');
            const mergeableCompany = yesCompany && noCompany ? 
                (yesCompany.balance < noCompany.balance ? yesCompany.balance : noCompany.balance) : 0n;
            
            // Find YES/NO pairs for currency tokens
            const yesCurrency = balances.find(b => b.label === 'YES_CURRENCY');
            const noCurrency = balances.find(b => b.label === 'NO_CURRENCY');
            const mergeableCurrency = yesCurrency && noCurrency ? 
                (yesCurrency.balance < noCurrency.balance ? yesCurrency.balance : noCurrency.balance) : 0n;
            
            spinner.stop();
            
            // Show mergeable amounts
            console.log(chalk.cyan('\nðŸ”€ Mergeable Positions:'));
            
            const mergeOptions = [];
            if (mergeableCompany > 0n) {
                console.log(chalk.gray(`  Company tokens (PNK):`));
                console.log(chalk.gray(`    YES_COMPANY: ${formatEther(yesCompany.balance)}`));
                console.log(chalk.gray(`    NO_COMPANY: ${formatEther(noCompany.balance)}`));
                console.log(chalk.green(`    Mergeable: ${formatEther(mergeableCompany)}`));
                mergeOptions.push({ 
                    name: `Merge ${formatEther(mergeableCompany)} Company tokens back to PNK`, 
                    value: 'company',
                    amount: mergeableCompany
                });
            }
            
            if (mergeableCurrency > 0n) {
                console.log(chalk.gray(`  Currency tokens (sDAI):`));
                console.log(chalk.gray(`    YES_CURRENCY: ${formatEther(yesCurrency.balance)}`));
                console.log(chalk.gray(`    NO_CURRENCY: ${formatEther(noCurrency.balance)}`));
                console.log(chalk.green(`    Mergeable: ${formatEther(mergeableCurrency)}`));
                mergeOptions.push({ 
                    name: `Merge ${formatEther(mergeableCurrency)} Currency tokens back to sDAI`, 
                    value: 'currency',
                    amount: mergeableCurrency
                });
            }
            
            if (mergeOptions.length === 0) {
                console.log(chalk.yellow('\nâš ï¸  No mergeable positions (need equal YES and NO tokens)'));
                return;
            }
            
            const { mergeChoice } = await inquirer.prompt([
                {
                    type: 'list',
                    name: 'mergeChoice',
                    message: 'Which tokens to merge?',
                    choices: [...mergeOptions, { name: 'Cancel', value: 'cancel' }]
                }
            ]);
            
            if (mergeChoice === 'cancel') return;
            
            const mergeSpinner = ora('Merging positions...').start();
            
            // Determine collateral token and amount
            const isCompany = mergeChoice === 'company';
            const collateralToken = isCompany ? this.tokens.companyToken : this.tokens.currencyToken;
            const mergeAmount = isCompany ? mergeableCompany : mergeableCurrency;
            const yesToken = isCompany ? yesCompany.address : yesCurrency.address;
            const noToken = isCompany ? noCompany.address : noCurrency.address;
            
            // Check and approve YES token
            await this.ensureApproval(yesToken, ROUTER_ADDRESS, mergeAmount);
            // Check and approve NO token  
            await this.ensureApproval(noToken, ROUTER_ADDRESS, mergeAmount);
            
            // Execute merge
            for await (const status of this.dataLayer.execute('futarchy.mergePositions', {
                proposal: this.proposal.address,
                collateralToken: collateralToken,
                amount: mergeAmount
            })) {
                mergeSpinner.text = status.message;
                
                if (status.status === 'success') {
                    mergeSpinner.succeed(`Successfully merged ${formatEther(mergeAmount)} YES/NO tokens back to collateral!`);
                    console.log(chalk.green('âœ… Transaction:'), status.data.transactionHash);
                    
                    // Refresh balances
                    await this.fetchBalances();
                }
            }
            
        } catch (error) {
            spinner.fail(`Failed to merge: ${error.message}`);
        }
    }
    
    async swapTokens() {
        if (!this.isConnected) {
            console.log(chalk.red('âŒ Wallet not connected'));
            return;
        }
        
        const spinner = ora('Loading balances...').start();
        
        try {
            // Get all token balances
            const [companyBalance, currencyBalance] = await Promise.all([
                this.publicClient.readContract({
                    address: this.tokens.companyToken,
                    abi: [{
                        name: 'balanceOf',
                        type: 'function',
                        stateMutability: 'view',
                        inputs: [{ name: 'account', type: 'address' }],
                        outputs: [{ name: '', type: 'uint256' }]
                    }],
                    functionName: 'balanceOf',
                    args: [this.account.address]
                }),
                this.publicClient.readContract({
                    address: this.tokens.currencyToken,
                    abi: [{
                        name: 'balanceOf',
                        type: 'function',
                        stateMutability: 'view',
                        inputs: [{ name: 'account', type: 'address' }],
                        outputs: [{ name: '', type: 'uint256' }]
                    }],
                    functionName: 'balanceOf',
                    args: [this.account.address]
                })
            ]);
            
            // Get conditional token balances
            const conditionalBalances = await Promise.all(
                this.proposal.wrapped.wrappedOutcomes.map(async (outcome) => {
                    const balance = await this.publicClient.readContract({
                        address: outcome.wrapped1155,
                        abi: [{
                            name: 'balanceOf',
                            type: 'function',
                            stateMutability: 'view',
                            inputs: [{ name: 'account', type: 'address' }],
                            outputs: [{ name: '', type: 'uint256' }]
                        }],
                        functionName: 'balanceOf',
                        args: [this.account.address]
                    }).catch(() => 0n);
                    
                    return { label: outcome.label, balance };
                })
            );
            
            spinner.stop();
            
            // Show conditional pool prices
            console.log('\n' + chalk.cyan('ðŸ’± Conditional Pool Swap'));
            console.log(chalk.gray('Trade between YES_COMPANY and YES_CURRENCY (or NO pairs)\n'));
            
            // Find conditional pools
            const yesPool = this.pools.conditionalPools.find(p => p.name === 'YES_COMPANY/YES_CURRENCY');
            const noPool = this.pools.conditionalPools.find(p => p.name === 'NO_COMPANY/NO_CURRENCY');
            
            if (yesPool) {
                const price = this.prices['YES_COMPANY/YES_CURRENCY'];
                const yesCompanyIsToken0 = price.token0.toLowerCase() === this.tokens.yesCompany.toLowerCase();
                const rate = yesCompanyIsToken0 ? price.price : price.priceInverse;
                console.log(chalk.green(`YES Pool: 1 YES_COMPANY = ${rate.toFixed(4)} YES_CURRENCY`));
            }
            
            if (noPool) {
                const price = this.prices['NO_COMPANY/NO_CURRENCY'];
                const noCompanyIsToken0 = price.token0.toLowerCase() === this.tokens.noCompany.toLowerCase();
                const rate = noCompanyIsToken0 ? price.price : price.priceInverse;
                console.log(chalk.red(`NO Pool: 1 NO_COMPANY = ${rate.toFixed(4)} NO_CURRENCY`));
            }
            
            const { outcome, side, amount } = await inquirer.prompt([
                {
                    type: 'list',
                    name: 'outcome',
                    message: 'Which outcome to trade?',
                    choices: [
                        { name: chalk.green('YES (believe proposal will pass)'), value: 'YES' },
                        { name: chalk.red('NO (believe proposal will fail)'), value: 'NO' }
                    ]
                },
                {
                    type: 'list',
                    name: 'side',
                    message: 'Trade direction?',
                    choices: [
                        { name: 'ðŸ“ˆ BUY Company tokens (swap Currency â†’ Company)', value: 'BUY' },
                        { name: 'ðŸ“‰ SELL Company tokens (swap Company â†’ Currency)', value: 'SELL' }
                    ]
                },
                {
                    type: 'input',
                    name: 'amount',
                    message: (answers) => {
                        // Calculate available balance
                        const isYes = answers.outcome === 'YES';
                        const isBuy = answers.side === 'BUY';
                        
                        if (isBuy) {
                            // Buying company with currency
                            const currencyToken = isYes ? 'YES_CURRENCY' : 'NO_CURRENCY';
                            const existing = conditionalBalances.find(b => b.label === currencyToken)?.balance || 0n;
                            const splittable = currencyBalance;
                            const total = existing + splittable;
                            
                            return `Amount of ${currencyToken} to swap (available: ${formatEther(existing)} + ${formatEther(splittable)} splittable = ${formatEther(total)} total):`;
                        } else {
                            // Selling company for currency
                            const companyToken = isYes ? 'YES_COMPANY' : 'NO_COMPANY';
                            const existing = conditionalBalances.find(b => b.label === companyToken)?.balance || 0n;
                            const splittable = companyBalance;
                            const total = existing + splittable;
                            
                            return `Amount of ${companyToken} to swap (available: ${formatEther(existing)} + ${formatEther(splittable)} splittable = ${formatEther(total)} total):`;
                        }
                    },
                    default: '0.01',
                    validate: (input, answers) => {
                        const num = parseFloat(input);
                        if (num <= 0) return 'Please enter a positive amount';
                        
                        // Check total available balance
                        const isYes = answers.outcome === 'YES';
                        const isBuy = answers.side === 'BUY';
                        
                        if (isBuy) {
                            const currencyToken = isYes ? 'YES_CURRENCY' : 'NO_CURRENCY';
                            const existing = conditionalBalances.find(b => b.label === currencyToken)?.balance || 0n;
                            const total = existing + currencyBalance;
                            if (parseEther(input) > total) return 'Amount exceeds available balance';
                        } else {
                            const companyToken = isYes ? 'YES_COMPANY' : 'NO_COMPANY';
                            const existing = conditionalBalances.find(b => b.label === companyToken)?.balance || 0n;
                            const total = existing + companyBalance;
                            if (parseEther(input) > total) return 'Amount exceeds available balance';
                        }
                        
                        return true;
                    }
                }
            ]);
            
            const swapSpinner = ora('Preparing smart swap...').start();
            
            // Determine tokens and amounts
            const isYes = outcome === 'YES';
            const isBuy = side === 'BUY';
            const amountWei = parseEther(amount);
            
            let tokenIn, tokenOut;
            if (isBuy) {
                // Buying company with currency
                tokenIn = isYes ? this.tokens.yesCurrency : this.tokens.noCurrency;
                tokenOut = isYes ? this.tokens.yesCompany : this.tokens.noCompany;
            } else {
                // Selling company for currency
                tokenIn = isYes ? this.tokens.yesCompany : this.tokens.noCompany;
                tokenOut = isYes ? this.tokens.yesCurrency : this.tokens.noCurrency;
            }
            
            // Get wrapped token addresses
            const tokenInLabel = isBuy ? 
                (isYes ? 'YES_CURRENCY' : 'NO_CURRENCY') : 
                (isYes ? 'YES_COMPANY' : 'NO_COMPANY');
            const tokenOutLabel = isBuy ?
                (isYes ? 'YES_COMPANY' : 'NO_COMPANY') :
                (isYes ? 'YES_CURRENCY' : 'NO_CURRENCY');
            const tokenInWrapped = this.proposal.wrapped.wrappedOutcomes.find(o => o.label === tokenInLabel)?.wrapped1155;
            const tokenOutWrapped = this.proposal.wrapped.wrappedOutcomes.find(o => o.label === tokenOutLabel)?.wrapped1155;
            
            // Check existing balance
            const existingBalance = conditionalBalances.find(b => b.label === tokenInLabel)?.balance || 0n;
            
            // Split if needed
            if (existingBalance < amountWei) {
                const splitNeeded = amountWei - existingBalance;
                swapSpinner.text = `Need to split ${formatEther(splitNeeded)} more tokens...`;
                
                // Determine which collateral to split
                const collateralToken = isBuy ? this.tokens.currencyToken : this.tokens.companyToken;
                
                // Ensure approval for splitting
                await this.ensureApproval(collateralToken, ROUTER_ADDRESS, splitNeeded);
                
                // Execute split
                swapSpinner.text = 'Splitting collateral into conditional tokens...';
                for await (const status of this.dataLayer.execute('futarchy.splitPosition', {
                    proposal: this.proposal.address,
                    amount: splitNeeded,
                    collateralToken: collateralToken
                })) {
                    if (status.status === 'success') {
                        swapSpinner.text = 'Split complete, preparing swap...';
                        console.log(chalk.green('\nâœ… Split transaction:'), status.data.transactionHash);
                    } else if (status.status === 'error') {
                        throw new Error(`Split failed: ${status.error}`);
                    }
                }
            }
            
            // Find the pool
            const poolName = isYes ? 'YES_COMPANY/YES_CURRENCY' : 'NO_COMPANY/NO_CURRENCY';
            const pool = this.pools.conditionalPools.find(p => p.name === poolName);
            
            if (!pool) {
                throw new Error(`${poolName} pool not found`);
            }
            
            // Get token decimals for proper calculation
            swapSpinner.text = 'Getting token information...';
            const [tokenInDecimals, tokenOutDecimals] = await Promise.all([
                this.publicClient.readContract({
                    address: tokenInWrapped,
                    abi: [{
                        name: 'decimals',
                        type: 'function',
                        stateMutability: 'view',
                        inputs: [],
                        outputs: [{ name: '', type: 'uint8' }]
                    }],
                    functionName: 'decimals'
                }).catch(() => 18), // Default to 18 decimals
                this.publicClient.readContract({
                    address: tokenOutWrapped,
                    abi: [{
                        name: 'decimals',
                        type: 'function',
                        stateMutability: 'view',
                        inputs: [],
                        outputs: [{ name: '', type: 'uint8' }]
                    }],
                    functionName: 'decimals'
                }).catch(() => 18)
            ]);
            
            // Calculate expected output based on pool price
            const price = this.prices[poolName];
            if (!price) {
                throw new Error(`Price data not available for ${poolName}`);
            }
            
            // Determine the correct price based on token ordering
            let expectedAmountOut;
            if (isBuy) {
                // Buying company with currency
                // If company is token0, we use priceInverse (currency per company)
                const companyIsToken0 = price.token0.toLowerCase() === tokenOutWrapped.toLowerCase();
                const rate = companyIsToken0 ? price.priceInverse : price.price;
                expectedAmountOut = parseFloat(amount) / rate;
            } else {
                // Selling company for currency  
                // If company is token0, we use price (currency per company)
                const companyIsToken0 = price.token0.toLowerCase() === tokenIn.toLowerCase();
                const rate = companyIsToken0 ? price.price : price.priceInverse;
                expectedAmountOut = parseFloat(amount) * rate;
            }
            
            // Ask for slippage tolerance
            const { slippage } = await inquirer.prompt([
                {
                    type: 'input',
                    name: 'slippage',
                    message: 'Slippage tolerance (%):',
                    default: '0.5',
                    validate: (input) => {
                        const num = parseFloat(input);
                        return num >= 0 && num <= 50 || 'Please enter a valid slippage (0-50%)';
                    }
                }
            ]);
            
            // Calculate minimum output with slippage
            const slippageBps = Math.floor(parseFloat(slippage) * 100); // Convert to basis points
            const slippageMultiplier = 1 - (slippageBps / 10000);
            const minAmountOut = expectedAmountOut * slippageMultiplier;
            
            // Convert to wei using proper decimals
            const minAmountOutWei = BigInt(Math.floor(minAmountOut * (10 ** tokenOutDecimals)));
            
            console.log(chalk.cyan('\nðŸ“Š Swap Details:'));
            console.log(chalk.gray(`  Pool: ${poolName}`));
            console.log(chalk.gray(`  Input: ${amount} ${tokenInLabel}`));
            console.log(chalk.gray(`  Expected output: ${expectedAmountOut.toFixed(6)} ${tokenOutLabel}`));
            console.log(chalk.gray(`  Minimum output (${slippage}% slippage): ${minAmountOut.toFixed(6)} ${tokenOutLabel}`));
            
            // Ensure approval for swap
            swapSpinner.text = 'Checking token approval for swap...';
            await this.ensureApproval(tokenInWrapped, '0xffb643e73f280b97809a8b41f7232ab401a04ee1', amountWei);
            
            // Execute swap through Algebra router
            swapSpinner.text = 'Executing swap on Algebra...';
            
            const deadline = Math.floor(Date.now() / 1000) + 1200; // 20 minutes from now
            
            try {
                const hash = await this.walletClient.writeContract({
                    address: '0xffb643e73f280b97809a8b41f7232ab401a04ee1', // Swapr V3 Router
                    abi: [{
                        "name": "exactInputSingle",
                        "type": "function",
                        "stateMutability": "payable",
                        "inputs": [
                            {
                                "name": "params",
                                "type": "tuple",
                                "components": [
                                    {"name": "tokenIn", "type": "address"},
                                    {"name": "tokenOut", "type": "address"},
                                    {"name": "recipient", "type": "address"},
                                    {"name": "deadline", "type": "uint256"},
                                    {"name": "amountIn", "type": "uint256"},
                                    {"name": "amountOutMinimum", "type": "uint256"},
                                    {"name": "limitSqrtPrice", "type": "uint160"}
                                ]
                            }
                        ],
                        "outputs": [{"name": "amountOut", "type": "uint256"}]
                    }],
                    functionName: 'exactInputSingle',
                    args: [{
                        tokenIn: tokenInWrapped,
                        tokenOut: tokenOutWrapped,
                        recipient: this.account.address,
                        deadline: BigInt(deadline),
                        amountIn: amountWei,
                        amountOutMinimum: minAmountOutWei,
                        limitSqrtPrice: 0n
                    }],
                    account: this.account
                });
                
                swapSpinner.text = 'Waiting for transaction confirmation...';
                const receipt = await this.publicClient.waitForTransactionReceipt({ hash });
                
                swapSpinner.succeed(`Swap executed successfully!`);
                console.log(chalk.green('âœ… Transaction:'), hash);
                console.log(chalk.gray(`  Gas used: ${receipt.gasUsed.toString()}`));
                
                // Refresh balances
                await this.fetchBalances();
                
            } catch (error) {
                // If direct swap fails, show error but suggest alternatives
                swapSpinner.fail('Direct swap failed');
                console.log(chalk.yellow('\nâš ï¸  Swap failed. This might be due to:'));
                console.log(chalk.gray('  - Insufficient liquidity in the pool'));
                console.log(chalk.gray('  - Price moved beyond slippage tolerance'));
                console.log(chalk.gray('  - Pool may need initialization'));
                throw error;
            }
            
        } catch (error) {
            spinner.fail(`Failed to swap: ${error.message}`);
        }
    }
    
    async ensureApproval(tokenAddress, spenderAddress, amount) {
        // Check current allowance
        const allowance = await this.publicClient.readContract({
            address: tokenAddress,
            abi: [{
                name: 'allowance',
                type: 'function',
                stateMutability: 'view',
                inputs: [
                    { name: 'owner', type: 'address' },
                    { name: 'spender', type: 'address' }
                ],
                outputs: [{ name: '', type: 'uint256' }]
            }],
            functionName: 'allowance',
            args: [this.account.address, spenderAddress]
        });
        
        if (allowance < amount) {
            const spinner = ora('Approving tokens...').start();
            
            try {
                const hash = await this.walletClient.writeContract({
                    address: tokenAddress,
                    abi: [{
                        name: 'approve',
                        type: 'function',
                        stateMutability: 'nonpayable',
                        inputs: [
                            { name: 'spender', type: 'address' },
                            { name: 'amount', type: 'uint256' }
                        ],
                        outputs: [{ name: '', type: 'bool' }]
                    }],
                    functionName: 'approve',
                    args: [spenderAddress, amount],
                    account: this.account
                });
                
                await this.publicClient.waitForTransactionReceipt({ hash });
                spinner.succeed('Approval granted');
            } catch (error) {
                spinner.fail('Approval failed');
                throw error;
            }
        } else {
            console.log(chalk.gray('âœ“ Token already approved'));
        }
    }
    
    async mainMenu() {
        const choices = [
            'ðŸ“Š View Prices & Probabilities',
            'ðŸ’° View Balances',
            'ðŸ”„ Split Position',
            'ðŸ”€ Merge Position',
            'ðŸ’± Swap Tokens',
            'ðŸ’¸ Redeem Position',
            'ðŸ”„ Change Proposal',
            'âŒ Exit'
        ];
        
        if (!this.isConnected) {
            // Remove write operations in read-only mode
            choices.splice(2, 4);
        }
        
        const { action } = await inquirer.prompt([
            {
                type: 'list',
                name: 'action',
                message: 'What would you like to do?',
                choices
            }
        ]);
        
        switch (action) {
            case 'ðŸ“Š View Prices & Probabilities':
                await this.discoverPools();
                break;
            case 'ðŸ’° View Balances':
                await this.fetchBalances();
                break;
            case 'ðŸ”„ Split Position':
                await this.splitPosition();
                break;
            case 'ðŸ”€ Merge Position':
                await this.mergePosition();
                break;
            case 'ðŸ’± Swap Tokens':
                await this.swapTokens();
                break;
            case 'ðŸ’¸ Redeem Position':
                await this.redeemPosition();
                break;
            case 'ðŸ”„ Change Proposal':
                await this.selectProposal();
                await this.discoverPools();
                if (this.isConnected) await this.fetchBalances();
                break;
            case 'âŒ Exit':
                return false;
        }
        
        return true;
    }
    
    getStatusColor(status) {
        const colors = {
            'FINALIZED': chalk.green(status),
            'OPEN_FOR_ANSWERS': chalk.yellow(status),
            'PENDING_ARBITRATION': chalk.red(status),
            'NOT_OPENED': chalk.gray(status)
        };
        return colors[status] || chalk.white(status);
    }
    
    async run() {
        await this.initialize();
        await this.selectProposal();
        await this.discoverPools();
        
        if (this.isConnected) {
            await this.fetchBalances();
        }
        
        // Main loop
        let running = true;
        while (running) {
            console.log('\n' + chalk.gray('â”€'.repeat(50)) + '\n');
            running = await this.mainMenu();
        }
        
        console.log('\n' + chalk.cyan.bold('ðŸ‘‹ Thanks for using Futarchy Manager!'));
        process.exit(0);
    }
}

// Run the manager
const manager = new FutarchyManager();
manager.run().catch(console.error);