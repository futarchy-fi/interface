<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Ethereum Futarchy App</title>
  <!-- Include ethers.js via CDN -->
  <script src="https://ipfs.io/ipfs/bafybeidyvcc4amuk5cvhyceojezekbocjvi2nfgvcvobj5fayvtfzk42im"></script>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 0;
      padding: 20px;
      background-color: #f5f5f5;
    }
    .container {
      display: flex;
      flex-direction: column;
      gap: 20px;
    }
    .card {
      background-color: white;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      padding: 20px;
      margin-bottom: 20px;
    }
    .section {
      margin-bottom: 15px;
    }
    .section-title {
      font-weight: bold;
      margin-bottom: 10px;
    }
    .info-row {
      display: flex;
      justify-content: space-between;
      margin-bottom: 5px;
    }
    .price-value {
      font-weight: bold;
      font-family: monospace;
    }
    .probability-value {
      font-weight: bold;
      color: #3498db;
    }
    .refresh-container {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-top: 10px;
    }
    .last-updated {
      font-size: 0.8em;
      color: #777;
      font-style: italic;
    }
    .error-message {
      background-color: #ffebee;
      border-left: 4px solid #f44336;
      padding: 10px;
      margin: 10px 0;
      color: #d32f2f;
      font-size: 0.9em;
    }
    .button {
      background-color: #4CAF50;
      border: none;
      color: white;
      padding: 10px 15px;
      text-align: center;
      text-decoration: none;
      display: inline-block;
      font-size: 14px;
      margin: 4px 2px;
      cursor: pointer;
      border-radius: 4px;
    }
    .button:hover {
      background-color: #45a049;
    }
    .button:disabled {
      background-color: #cccccc;
      cursor: not-allowed;
    }
    .input-group {
      margin-bottom: 10px;
    }
    input[type="number"] {
      padding: 8px;
      margin-right: 5px;
      border: 1px solid #ddd;
      border-radius: 4px;
    }
    .status {
      margin-top: 10px;
      padding: 10px;
      border-radius: 4px;
    }
    .info {
      background-color: #d9edf7;
      color: #31708f;
    }
    .success {
      background-color: #dff0d8;
      color: #3c763d;
    }
    .warning {
      background-color: #fcf8e3;
      color: #8a6d3b;
    }
    .error {
      background-color: #f2dede;
      color: #a94442;
    }
    .transaction-item {
      margin-bottom: 5px;
      padding: 5px;
      border-bottom: 1px solid #eee;
    }
    .transaction-hash {
      font-size: 12px;
      color: #666;
      word-break: break-all;
    }
    .transaction-hash:hover {
      text-decoration: underline;
    }
    .token-toggle, .action-toggle {
      display: flex;
      align-items: center;
      margin-bottom: 10px;
    }
    .toggle-container {
      display: flex;
      background-color: #f0f0f0;
      border-radius: 20px;
      padding: 3px;
      margin-left: 10px;
    }
    .toggle-container input[type="radio"] {
      display: none;
    }
    .toggle-container label {
      padding: 5px 15px;
      cursor: pointer;
      border-radius: 20px;
      margin: 0 2px;
      transition: all 0.3s ease;
    }
    .toggle-container input[type="radio"]:checked + label {
      background-color: #4CAF50;
      color: white;
    }
    .grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
      gap: 20px;
    }
    .token-balance {
      display: flex;
      justify-content: space-between;
      margin-bottom: 5px;
    }
    .loading {
      display: inline-block;
      width: 20px;
      height: 20px;
      border: 3px solid rgba(0,0,0,0.1);
      border-radius: 50%;
      border-top-color: #3498db;
      animation: spin 1s ease-in-out infinite;
      margin-left: 10px;
    }
    @keyframes spin {
      to { transform: rotate(360deg); }
    }
    .tx-link {
      color: #3498db;
      text-decoration: none;
    }
    .tx-link:hover {
      text-decoration: underline;
    }
    .input-label {
      display: block;
      margin-bottom: 5px;
      font-weight: bold;
    }
    .action-button {
      margin-top: 15px;
      width: 100%;
      padding: 12px;
      font-size: 16px;
    }
    .available-balance {
      margin-bottom: 10px;
    }
    .balance-title {
      font-weight: bold;
    }
    .balance-amount {
      margin-top: 5px;
    }
    .balance-breakdown {
      margin-top: 5px;
    }
    .swap-steps-container {
      margin-bottom: 10px;
    }
    .swap-step {
      margin-bottom: 10px;
    }
    .step-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .step-number {
      font-weight: bold;
    }
    .step-title {
      font-weight: bold;
    }
    .step-status {
      font-weight: bold;
    }
    .step-details {
      margin-top: 5px;
    }
    .substep {
      margin-bottom: 5px;
    }
    .substep-indicator {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      background-color: #ddd;
      margin-right: 5px;
    }
    .substep-text {
      font-weight: normal;
    }
    /* Debug button styles */
    #debug-button-container {
      display: none;
      margin-top: 20px;
      text-align: center;
    }
    #debug-button {
      background-color: #f0ad4e;
      color: white;
      border: none;
      padding: 8px 16px;
      border-radius: 4px;
      cursor: pointer;
    }
    #debug-button:hover {
      background-color: #ec971f;
    }
    .loading-spinner {
      display: inline-block;
      width: 20px;
      height: 20px;
      border: 3px solid rgba(0,0,0,0.1);
      border-radius: 50%;
      border-top-color: #3498db;
      animation: spin 1s ease-in-out infinite;
      margin-left: 10px;
    }
    
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="card">
      <div class="section-title">Ethereum Connection</div>
      <div id="wallet-info">
        <p>Status: <span id="connection-status">Not connected</span></p>
        <p>Address: <span id="wallet-address">-</span></p>
        <p>Chain ID: <span id="chain-id">-</span></p>
      </div>
      <button id="connect-wallet" class="button">Connect MetaMask</button>
      <div id="connection-message" class="status"></div>
    </div>

    <div class="card">
      <div class="section-title">Token Balances</div>
      <div id="balance-info">
        <div class="section">
          <div class="section-title">Company</div>
          <div class="token-balance">
            <span>Wallet:</span>
            <span id="company-wallet-balance">0.0</span>
          </div>
          <div class="token-balance">
            <span>Yes Tokens:</span>
            <span id="company-yes-balance">0.0</span>
          </div>
          <div class="token-balance">
            <span>No Tokens:</span>
            <span id="company-no-balance">0.0</span>
          </div>
          <div class="token-balance">
            <span>Total Position:</span>
            <span id="company-total-position">0.0</span>
          </div>
          <div class="token-balance">
            <span>RECEIVE:</span>
            <span id="company-position-outcome">IF YES 0.0</span>
          </div>
        </div>
        
        <div class="section">
          <div class="section-title">Currency</div>
          <div class="token-balance">
            <span>Wallet:</span>
            <span id="currency-wallet-balance">0.0</span>
          </div>
          <div class="token-balance">
            <span>Yes Tokens:</span>
            <span id="currency-yes-balance">0.0</span>
          </div>
          <div class="token-balance">
            <span>No Tokens:</span>
            <span id="currency-no-balance">0.0</span>
          </div>
          <div class="token-balance">
            <span>Total Position:</span>
            <span id="currency-total-position">0.0</span>
          </div>
          <div class="token-balance">
            <span>RECOVER:</span>
            <span id="currency-position-outcome">IF NO 0.0</span>
          </div>
        </div>
      </div>
      <div class="token-balance">
        <button id="refresh-balances" class="button">Refresh Balances</button>
        <button id="auto-refresh-toggle" class="button">Start Auto-Refresh</button>
      </div>
      <div id="balance-message" class="status"></div>
    </div>

  
    <div class="card">
      <div class="section-title">Token Approvals</div>
      <div class="section">
        <div class="section-title">Currency Token</div>
        <button id="approve-currency" class="button">Approve Currency Token</button>
      </div>
      <div class="section">
        <div class="section-title">Company Token</div>
        <button id="approve-company" class="button">Approve Company Token</button>
      </div>
      <div id="approval-message" class="status"></div>
    </div>


    <div class="card">
      <div class="section-title">Swap Tokens</div>
      <div class="section">
        <div class="input-group">
          <label for="swap-amount" class="input-label">Amount:</label>
          <input type="number" id="swap-amount" placeholder="Amount to swap">
          <button id="max-button" class="button max-button">MAX</button>
          
          <div class="available-balance">
            <div class="balance-title">Available Balance:</div>
            <div id="available-balance-amount" class="balance-amount">0</div>
            <div id="balance-breakdown" class="balance-breakdown">
              <div>Wallet: <span id="wallet-balance-for-swap">0</span></div>
              <div>Position: <span id="position-balance-for-swap">0</span></div>
        </div>
      </div>
          
          <div class="token-toggle">
            <label>Token Type:</label>
            <div class="toggle-container">
              <input type="radio" id="yes-toggle" name="token-type" value="yes" checked>
              <label for="yes-toggle">YES</label>
              <input type="radio" id="no-toggle" name="token-type" value="no">
              <label for="no-toggle">NO</label>
        </div>
      </div>
          
          <div class="action-toggle">
            <label>Action:</label>
            <div class="toggle-container">
              <input type="radio" id="buy-toggle" name="action-type" value="buy" checked>
              <label for="buy-toggle">Buy with Currency</label>
              <input type="radio" id="sell-toggle" name="action-type" value="sell">
              <label for="sell-toggle">Sell for Currency</label>
            </div>
          </div>
          
          <button id="execute-swap" class="button action-button">Execute Swap</button>
        </div>
      </div>
      
      <div id="swap-steps" class="swap-steps-container">
        <div class="swap-step">
          <div class="step-header">
            <div class="step-number">1</div>
            <div class="step-title">Check Balances</div>
            <div class="step-status" id="step1-status">Waiting</div>
          </div>
          <div class="step-details">
            <div class="substep">
              <div class="substep-indicator"></div>
              <div class="substep-text">Checking available balances</div>
            </div>
          </div>
        </div>
        
        <div class="swap-step">
          <div class="step-header">
            <div class="step-number">2</div>
            <div class="step-title">Add Collateral (if needed)</div>
            <div class="step-status" id="step2-status">Waiting</div>
          </div>
          <div class="step-details">
            <div class="substep">
              <div class="substep-indicator"></div>
              <div class="substep-text">Check if additional collateral is needed</div>
            </div>
            <div class="substep">
              <div class="substep-indicator"></div>
              <div class="substep-text">Approve tokens for collateral</div>
            </div>
            <div class="substep">
              <div class="substep-indicator"></div>
              <div class="substep-text">Split position</div>
            </div>
          </div>
        </div>
        
        <div class="swap-step">
          <div class="step-header">
            <div class="step-number">3</div>
            <div class="step-title">Execute Swap</div>
            <div class="step-status" id="step3-status">Waiting</div>
          </div>
          <div class="step-details">
            <div class="substep">
              <div class="substep-indicator"></div>
              <div class="substep-text">Approve tokens for swap</div>
            </div>
            <div class="substep">
              <div class="substep-indicator"></div>
              <div class="substep-text">Execute swap transaction</div>
            </div>
            <div class="substep">
              <div class="substep-indicator"></div>
              <div class="substep-text">Confirm transaction</div>
            </div>
          </div>
        </div>
      </div>
      
      <div id="swap-message" class="status"></div>
    </div>

    <div class="card">
      <div class="section-title">Add & Remove Collateral</div>
      <div class="section">
        <div class="section-title">Currency Collateral</div>
        <div class="input-group">
          <input type="number" id="currency-split-amount" placeholder="Amount to add/remove">
          <button id="currency-split" class="button">Add</button>
          <button id="currency-merge" class="button">Remove</button>
        </div>
      </div>
      <div class="section">
        <div class="section-title">Company Collateral</div>
        <div class="input-group">
          <input type="number" id="company-split-amount" placeholder="Amount to add/remove">
          <button id="company-split" class="button">Add</button>
          <button id="company-merge" class="button">Remove</button>
        </div>
      </div>
      <div id="collateral-message" class="status"></div>
    </div>

    <div class="card">
      <div class="section-title">Transaction History</div>
      <div id="tx-history"></div>
    </div>

    <div class="card">
      <div class="section-title">Market Prices & Probability</div>
      <div class="section">
        <div id="price-loading" style="display: none; text-align: center; margin-bottom: 10px;">
          <div class="loading-spinner"></div>
          <div>Fetching latest prices...</div>
        </div>
        <div class="info-row">
          <span>YES Company Price:</span>
          <span id="yes-company-price" class="price-value">Loading...</span>
        </div>
        <div class="info-row">
          <span>NO Company Price:</span>
          <span id="no-company-price" class="price-value">Loading...</span>
        </div>
        <div class="info-row">
          <span>YES Currency in XDAI:</span>
          <span id="yes-currency-price" class="price-value">Loading...</span>
        </div>
        <div class="info-row">
          <span>NO Currency in XDAI:</span>
          <span id="no-currency-price" class="price-value">Loading...</span>
        </div>
        <div class="info-row">
          <span>SDAI Price:</span>
          <span id="sdai-price" class="price-value">Loading...</span>
        </div>
        <div class="info-row">
          <span>Event Probability:</span>
          <span id="event-probability" class="probability-value">Loading...</span>
        </div>
        <div class="refresh-container">
          <span class="last-updated">Last Updated: <span id="last-updated">Never</span></span>
          <button id="refresh-prices" class="button">Refresh Prices</button>
          <button id="debug-prices" class="button" style="background-color: #f0ad4e; margin-left: 10px;">Debug Prices</button>
        </div>
        
        <div class="debug-section" style="margin-top: 20px; border-top: 1px solid #eee; padding-top: 10px;">
          <details>
            <summary style="cursor: pointer; font-weight: bold;">Debug Information</summary>
            <div style="margin-top: 10px; font-size: 0.9em; font-family: monospace; white-space: pre-wrap; background: #f5f5f5; padding: 10px; border-radius: 4px; overflow-x: auto;">
              <h4 style="margin: 0 0 10px 0;">Contract Addresses:</h4>
              <div>YES Pool: <span class="debug-value" id="debug-yes-pool-address"></span></div>
              <div>NO Pool: <span class="debug-value" id="debug-no-pool-address"></span></div>
              <div>SDAI Rate Provider: <span class="debug-value" id="debug-sdai-rate-address"></span></div>
              <div>WXDAI: <span class="debug-value" id="debug-wxdai-address"></span></div>
              <div>YES_SDAI: <span class="debug-value" id="debug-yes-sdai-address"></span></div>
              <div>NO_SDAI: <span class="debug-value" id="debug-no-sdai-address"></span></div>
              <div>YES_GNO: <span class="debug-value" id="debug-yes-gno-address"></span></div>
              <div>NO_GNO: <span class="debug-value" id="debug-no-gno-address"></span></div>
              
              <h4 style="margin: 10px 0;">Price Calculation Formula:</h4>
              <div>1. sqrtPriceX96 from Uniswap V3 Pool slot0()</div>
              <div>2. price = (sqrtPriceX96 * sqrtPriceX96) / 2^192</div>
              <div>3. If tokenCompanySlot is 1, price = 1 / price</div>
              
              <h4 style="margin: 10px 0;">Probability Calculation:</h4>
              <div>probability = YES_SDAI price in XDAI / SDAI price</div>
              
              <h4 style="margin: 10px 0;">Raw Data:</h4>
              <div id="debug-raw-data">No data fetched yet</div>
            </div>
          </details>
        </div>
      </div>
      <div id="price-message" class="status"></div>
    </div>

    <div id="debug-button-container">
      <button id="debug-button">Debug</button>
    </div>
  </div>

  <script>
    // Constants and Configuration
    // SushiSwap V3 Router Constants and ABIs
    const SUSHISWAP_V3_ROUTER = "0x592abc3734cd0d458e6e44a2db2992a3d00283a4";
    
    const SUSHISWAP_V3_ROUTER_ABI = [
      "function exactInputSingle((address tokenIn, address tokenOut, uint24 fee, address recipient, uint256 amountIn, uint256 amountOutMinimum, uint160 sqrtPriceLimitX96)) external returns (uint256 amountOut)",
      "function exactOutputSingle((address tokenIn, address tokenOut, uint24 fee, address recipient, uint256 amountOut, uint256 amountInMaximum, uint160 sqrtPriceLimitX96)) external returns (uint256 amountIn)",
      "function swap(address pool, address recipient, bool zeroForOne, int256 amountSpecified, uint160 sqrtPriceLimitX96, bytes data) external returns (int256, int256)"
    ];
    
    const UNISWAP_V3_POOL_ABI = [
      "function token0() external view returns (address)",
      "function token1() external view returns (address)",
      "function swap(address recipient, bool zeroForOne, int256 amountSpecified, uint160 sqrtPriceLimitX96, bytes data) external returns (int256, int256)",
      "function slot0() external view returns (uint160 sqrtPriceX96, int24 tick, uint16 observationIndex, uint16 observationCardinality, uint16 observationCardinalityNext, uint8 feeProtocol, bool unlocked)"
    ];
    
    const V3_POOL_CONFIG = {
      YES: {
        address: "0x9a14d28909f42823ee29847f87a15fb3b6e8aed3",
        tokenCurrencySlot: 1,
        tokenCompanySlot: 0,
        fee: 10000
      },
      NO: {
        address: "0x6E33153115Ab58dab0e0F1E3a2ccda6e67FA5cD7",
        tokenCurrencySlot: 0,
        tokenCompanySlot: 1,
        fee: 10000
      }
    };
    
    const MIN_SQRT_RATIO = "4295128740";
    const MAX_SQRT_RATIO = "1461446703485210103287273052203988822378723970341";
    
    // Token Configuration
    const TOKEN_CONFIG = {
      currency: {
        name: 'SDAI',
        address: '0xaf204776c7245bF4147c2612BF6e5972Ee483701',
        decimals: 18,
        getTokenAddresses: (eventHappens) => ({
          yes: '0x493A0D1c776f8797297Aa8B34594fBd0A7F8968a',
          no: '0xE1133Ef862f3441880adADC2096AB67c63f6E102'
        })
      },
      company: {
        name: 'GNO',
        address: '0x9C58BAcC331c9aa871AFD802DB6379a98e80CEdb',
        decimals: 18,
        getTokenAddresses: (eventHappens) => ({
          yes: '0x177304d505eCA60E1aE0dAF1bba4A4c4181dB8Ad',
          no: '0xf1B3E5Ffc0219A4F8C0ac69EC98C97709EdfB6c9'
        })
      },
      SUSHI_ROUTER: '0x592abc3734cd0d458e6e44a2db2992a3d00283a4' // SUSHISWAP_V3_ROUTER
    };

    const CONTRACT_ADDRESSES = {
      futarchyRouter: '0x7495a583ba85875d59407781b4958ED6e0E1228f',
      sushiswap: '0x592abc3734cd0d458e6e44a2db2992a3d00283a4', // Using SUSHISWAP_V3_ROUTER
      market: '0x6242AbA055957A63d682e9D3de3364ACB53D053A',
      conditionalTokens: '0xCeAfDD6bc0bEF976fdCd1112955828E00543c0Ce',
      wrapperService: '0xc14f5d2B9d6945EF1BA93f8dB20294b90FA5b5b1',
      vaultRelayer: '0xC92E8bdf79f0507f65a392b0ab4667716BFE0110',
      cowSettlement: '0x9008D19f58AAbD9eD0D60971565AA8510560ab41',
      baseCurrencyToken: '0xaf204776c7245bF4147c2612BF6e5972Ee483701', // SDAI
      baseCompanyToken: '0x9C58BAcC331c9aa871AFD802DB6379a98e80CEdb', // GNO
      currencyYesToken: '0x493A0D1c776f8797297Aa8B34594fBd0A7F8968a',
      currencyNoToken: '0xE1133Ef862f3441880adADC2096AB67c63f6E102',
      companyYesToken: '0x177304d505eCA60E1aE0dAF1bba4A4c4181dB8Ad',
      companyNoToken: '0xf1B3E5Ffc0219A4F8C0ac69EC98C97709EdfB6c9',
      poolYes: '0x9a14d28909f42823ee29847f87a15fb3b6e8aed3', // Matches POOL_CONFIG_YES.address
      poolNo: '0x6E33153115Ab58dab0e0F1E3a2ccda6e67FA5cD7', // Matches POOL_CONFIG_NO.address
      sdaiRateProvider: '0x89C80A4540A00b5270347E02e2E144c71da2EceD',
      wxdai: '0xe91D153E0b41518A2Ce8Dd3D7944Fa863463a97d',
      yes_sdai: '0x493A0D1c776f8797297Aa8B34594fBd0A7F8968a', // YES_SDAI token address
      no_sdai: '0xE1133Ef862f3441880adADC2096AB67c63f6E102',  // NO_SDAI token address (fixed checksum by using lowercase)
      yes_gno: '0x177304d505eCA60E1aE0dAF1bba4A4c4181dB8Ad', // YES_GNO token address
      no_gno: '0xf1B3E5Ffc0219A4F8C0ac69EC98C97709EdfB6c9'   // NO_GNO token address
    };

    const TRANSACTION_SETTINGS = {
      DEFAULT_GAS_LIMIT: ethers.BigNumber.from('2000000'),
      GAS_PRICE_BUFFER: 1.2, // 20% buffer
      CONFIRMATION_BLOCKS: 1,
      MAX_APPROVAL_AMOUNT: ethers.constants.MaxUint256,
      REFRESH_INTERVAL_MS: 5000,
      TRANSACTION_TYPE: 2,
      MAX_FEE_PER_GAS: ethers.utils.parseUnits("1.5", "gwei"),
      MAX_PRIORITY_FEE_PER_GAS: ethers.utils.parseUnits("1", "gwei")
    };

    const ERROR_MESSAGES = {
      NO_PROVIDER: 'No ethereum provider found',
      INSUFFICIENT_BALANCE: 'Insufficient balance',
      INVALID_AMOUNT: 'Invalid amount',
      USER_REJECTED: 'Transaction rejected by user',
      INSUFFICIENT_GAS: 'Insufficient funds for gas',
      GENERIC_ERROR: 'Transaction failed',
      SPLIT_ERROR: 'Error adding collateral'
    };

    const STATUS_MESSAGES = {
      PREPARING_TRANSACTION: 'Preparing transaction...',
      CHECKING_ALLOWANCE: 'Checking token allowance...',
      APPROVING_TOKEN: 'Approving token...',
      ESTIMATING_GAS: 'Estimating gas...',
      EXECUTING_SWAP: 'Executing swap...',
      WAITING_CONFIRMATION: 'Waiting for confirmation...',
      TRANSACTION_CONFIRMED: 'Transaction confirmed',
      TRANSACTION_FAILED: 'Transaction failed'
    };

    // SushiSwap V3 Helper Functions
    
    /**
     * Check and handle token approval for V3 swap
     */
    async function checkAndApproveTokenForV3Swap({
      signer,
      tokenAddress,
      amount,
      eventHappens,
      onApprovalNeeded,
      onApprovalComplete
    }) {
      try {
        const userAddress = await signer.getAddress();
        
        // We need to check and approve the router, not the pool
        const routerAddress = SUSHISWAP_V3_ROUTER;

        // Create token contract
        const tokenContract = new ethers.Contract(
          tokenAddress,
          [
            "function allowance(address owner, address spender) view returns (uint256)",
            "function approve(address spender, uint256 amount) returns (bool)"
          ],
          signer
        );

        // Check current allowance for the router
        const currentAllowance = await tokenContract.allowance(userAddress, routerAddress);
        
        console.log('Checking V3 swap allowance for router:', {
          token: tokenAddress,
          spender: routerAddress,
          currentAllowance: currentAllowance.toString(),
          requiredAmount: amount.toString(),
          hasEnoughAllowance: currentAllowance.gte(amount)
        });

        // If allowance is sufficient, return early
        if (currentAllowance.gte(amount)) {
          console.log('Token already approved for V3 router swap');
          return false; // No approval was needed
        }

        // Otherwise, request approval
        console.log('Insufficient allowance for V3 router swap, approving token...');
        
        if (onApprovalNeeded) {
          onApprovalNeeded();
        } else {
          showMessage('swap-message', 'Approving token for SushiSwap V3...', 'info');
        }
        
        // Skip resetting allowance - directly approve with new amount
        const approveTx = await tokenContract.approve(
          routerAddress,
          ethers.constants.MaxUint256, // Use max uint to avoid future approvals
          { 
            gasLimit: TRANSACTION_SETTINGS.DEFAULT_GAS_LIMIT,
            type: TRANSACTION_SETTINGS.TRANSACTION_TYPE,
            maxFeePerGas: TRANSACTION_SETTINGS.MAX_FEE_PER_GAS,
            maxPriorityFeePerGas: TRANSACTION_SETTINGS.MAX_PRIORITY_FEE_PER_GAS
          }
        );
        
        // Add approval transaction to history
        addTransactionToHistory(approveTx.hash, `Approved token for SushiSwap V3 swap`);
        
        await approveTx.wait();
        
        if (onApprovalComplete) {
          onApprovalComplete();
        } else {
          showMessage('swap-message', 'Token approved for SushiSwap V3', 'success');
        }
        
        return true; // Approval was needed and successful
        
      } catch (error) {
        console.error('Token approval for V3 router swap failed:', error);
        showMessage('swap-message', `Error: ${handleTransactionError(error)}`, 'error');
        throw new Error(`Failed to approve token for V3 router swap: ${error.message}`);
      }
    }

    /**
     * Execute a swap using SushiSwap V3 Router
     */
    async function executeV3Swap({
      signer,
      tokenIn,
      tokenOut,
      amount,
      eventHappens,
      options = {}
    }) {
      try {
        const userAddress = await signer.getAddress();
        
        // Determine which pool to use based on eventHappens
        const poolConfig = eventHappens ? V3_POOL_CONFIG.YES : V3_POOL_CONFIG.NO;
        const poolAddress = poolConfig.address;
        
        // Create router contract
        const routerContract = new ethers.Contract(
          SUSHISWAP_V3_ROUTER,
          SUSHISWAP_V3_ROUTER_ABI,
          signer
        );
        
        // We still need to query the pool to determine token positions
        const poolContract = new ethers.Contract(poolAddress, UNISWAP_V3_POOL_ABI, signer);
        
        // Get token0 and token1 from the pool
        const token0Address = await poolContract.token0();
        const token1Address = await poolContract.token1();
        
        console.log('Pool token verification:', {
          pool: poolAddress,
          token0: token0Address,
          token1: token1Address,
          tokenIn,
          tokenOut
        });
        
        // Determine zeroForOne based on tokenIn position
        // If tokenIn is token0, then zeroForOne is true
        // If tokenIn is token1, then zeroForOne is false
        const zeroForOne = tokenIn.toLowerCase() === token0Address.toLowerCase();
        
        // Set sqrtPriceLimitX96 based on swap direction
        const sqrtPriceLimitX96 = zeroForOne ? MIN_SQRT_RATIO : MAX_SQRT_RATIO;
        
        console.log('V3 Router Swap parameters:', {
          router: SUSHISWAP_V3_ROUTER,
          pool: poolAddress,
          recipient: userAddress,
          zeroForOne,
          amountSpecified: amount.toString(),
          sqrtPriceLimitX96,
          data: "0x"
        });
        
        // Execute the swap using the router
        const txOptions = {
          gasLimit: options.gasLimit || TRANSACTION_SETTINGS.DEFAULT_GAS_LIMIT,
          type: TRANSACTION_SETTINGS.TRANSACTION_TYPE,
          maxFeePerGas: TRANSACTION_SETTINGS.MAX_FEE_PER_GAS,
          maxPriorityFeePerGas: TRANSACTION_SETTINGS.MAX_PRIORITY_FEE_PER_GAS,
          ...options
        };
        
        const tx = await routerContract.swap(
          poolAddress,        // pool address
          userAddress,        // recipient
          zeroForOne,         // zeroForOne
          amount,             // amountSpecified
          sqrtPriceLimitX96,  // sqrtPriceLimitX96
          "0x",               // data - empty bytes
          txOptions
        );
        
        console.log('V3 Router Swap transaction sent:', tx.hash);
        
        return tx;
      } catch (error) {
        console.error('V3 Router Swap execution failed:', error);
        showMessage('swap-message', `Error: ${handleTransactionError(error)}`, 'error');
        throw error;
      }
    }

    // Basic ABIs
    const ERC20_ABI = [
      'function approve(address spender, uint256 amount) external returns (bool)',
      'function allowance(address owner, address spender) external view returns (uint256)',
      'function balanceOf(address account) external view returns (uint256)',
      'function transfer(address recipient, uint256 amount) external returns (bool)',
      'function transferFrom(address sender, address recipient, uint256 amount) external returns (bool)',
      'function decimals() view returns (uint8)',
      'function symbol() view returns (string)'
    ];

    // State management
    let state = {
      provider: null,
      signer: null,
      account: null,
      chainId: null,
      isConnected: false,
      isAutoRefreshing: false,
      refreshInterval: null,
      balances: {
        currency: {
          wallet: { amount: '0', formatted: '0' },
          collateral: { yes: '0', no: '0', total: 0, netPosition: 0 }
        },
        company: {
          wallet: { amount: '0', formatted: '0' },
          collateral: { yes: '0', no: '0', total: 0, netPosition: 0 }
        }
      },
      transactions: [],
      isApproving: {
        currency: false,
        company: false
      },
      isSwapping: false
    };

    // DOM elements
    const elements = {
      connectionStatus: document.getElementById('connection-status'),
      walletAddress: document.getElementById('wallet-address'),
      chainId: document.getElementById('chain-id'),
      connectWallet: document.getElementById('connect-wallet'),
      connectionMessage: document.getElementById('connection-message'),
      
      currencyWalletBalance: document.getElementById('currency-wallet-balance'),
      currencyYesBalance: document.getElementById('currency-yes-balance'),
      currencyNoBalance: document.getElementById('currency-no-balance'),
      currencyTotalPosition: document.getElementById('currency-total-position'),
      currencyNetPosition: document.getElementById('currency-net-position'),
      
      companyWalletBalance: document.getElementById('company-wallet-balance'),
      companyYesBalance: document.getElementById('company-yes-balance'),
      companyNoBalance: document.getElementById('company-no-balance'),
      companyTotalPosition: document.getElementById('company-total-position'),
      companyNetPosition: document.getElementById('company-net-position'),
      
      refreshBalances: document.getElementById('refresh-balances'),
      autoRefreshToggle: document.getElementById('auto-refresh-toggle'),
      balanceMessage: document.getElementById('balance-message'),
      
      approveCurrency: document.getElementById('approve-currency'),
      approveCompany: document.getElementById('approve-company'),
      approvalMessage: document.getElementById('approval-message'),
      
      swapAmount: document.getElementById('swap-amount'),
      executeSwap: document.getElementById('execute-swap'),
      
      currencySplitAmount: document.getElementById('currency-split-amount'),
      currencySplit: document.getElementById('currency-split'),
      currencyMerge: document.getElementById('currency-merge'),
      
      companySplitAmount: document.getElementById('company-split-amount'),
      companySplit: document.getElementById('company-split'),
      companyMerge: document.getElementById('company-merge'),
      
      collateralMessage: document.getElementById('collateral-message'),
      swapMessage: document.getElementById('swap-message'),
      txHistory: document.getElementById('tx-history'),
      
      yesToggle: document.getElementById('yes-toggle'),
      noToggle: document.getElementById('no-toggle'),
      buyToggle: document.getElementById('buy-toggle'),
      sellToggle: document.getElementById('sell-toggle'),
      
      yesCompanyPrice: document.getElementById('yes-company-price'),
      noCompanyPrice: document.getElementById('no-company-price'),
      yesCurrencyPrice: document.getElementById('yes-currency-price'),
      noCurrencyPrice: document.getElementById('no-currency-price'),
      sdaiPrice: document.getElementById('sdai-price'),
      eventProbability: document.getElementById('event-probability'),
      lastUpdated: document.getElementById('last-updated'),
      refreshPrices: document.getElementById('refresh-prices'),
      currencyPositionOutcome: document.getElementById('currency-position-outcome'),
      companyPositionOutcome: document.getElementById('company-position-outcome')
    };

    // Utility Functions
    function showMessage(elementId, message, type = 'info') {
      const element = document.getElementById(elementId);
      if (element) {
        element.textContent = message;
        element.className = `status ${type}`;
      }
    }

    function addTransactionToHistory(txHash, description) {
      const txItem = document.createElement('div');
      txItem.className = 'token-balance';
      
      const explorerUrl = getExplorerUrl(txHash);
      txItem.innerHTML = `
        <span>${description}</span>
        <a href="${explorerUrl}" target="_blank" class="tx-link">${truncateAddress(txHash)}</a>
      `;
      
      elements.txHistory.prepend(txItem);
      
      // Also add to state
      state.transactions.unshift({ hash: txHash, description, timestamp: new Date() });
      
      // Keep only the last 10 transactions
      if (state.transactions.length > 10) {
        state.transactions.pop();
      }
    }

    function getExplorerUrl(txHash) {
      // Use the appropriate explorer based on chain ID
      const explorerBaseUrl = state.chainId === 100 ? 'https://gnosisscan.io/tx/' : 'https://etherscan.io/tx/';
      return explorerBaseUrl + txHash;
    }

    function truncateAddress(address) {
      return address.slice(0, 6) + '...' + address.slice(-4);
    }

    function calculatePositionInfo(yesAmount, noAmount) {
      const yes = parseFloat(yesAmount);
      const no = parseFloat(noAmount);
      
      return {
        total: yes + no,
        netPosition: yes - no
      };
    }

    function formatTokenAmount(amount, decimals = 18) {
      try {
        if (!amount) return { amount: '0', formatted: '0' };
        
        const bigNumberAmount = ethers.BigNumber.from(amount);
        return {
          amount: bigNumberAmount.toString(),
          formatted: ethers.utils.formatUnits(bigNumberAmount, decimals)
        };
      } catch (err) {
        console.error('Error formatting token amount:', err);
        return { amount: '0', formatted: '0' };
      }
    }

    function parseTokenAmount(amount, decimals = 18) {
      try {
        return ethers.utils.parseUnits(amount.toString(), decimals);
      } catch (err) {
        console.error('Error parsing token amount:', err);
        return ethers.BigNumber.from(0);
      }
    }

    function validateTokenAmount(amount, balance, decimals = 18) {
      try {
        // Convert amount to BigNumber using parseUnits to handle decimals
        const parsedAmount = ethers.utils.parseUnits(amount.toString(), decimals);
        const parsedBalance = ethers.utils.parseUnits(balance.toString(), decimals);
        
        if (parsedAmount.lte(0)) {
          return { isValid: false, error: 'Amount must be greater than 0' };
        }
        
        if (parsedAmount.gt(parsedBalance)) {
          return { isValid: false, error: 'Insufficient balance' };
        }
        
        return { isValid: true, error: null };
      } catch (err) {
        console.error('Error validating token amount:', err);
        return { isValid: false, error: 'Invalid amount' };
      }
    }

    function handleTransactionError(error) {
      if (error.code === 4001) {
        return 'Transaction rejected by user';
      }
      
      if (error.code === -32603) {
        if (error.message.includes('insufficient funds')) {
          return 'Insufficient funds for gas';
        }
      }
      
      return error.message || 'Transaction failed';
    }

    // MetaMask Connection Functions
    async function connectWallet() {
      try {
        showMessage('connection-message', 'Connecting to MetaMask...', 'info');
        
        if (!window.ethereum) {
          throw new Error('MetaMask not found');
        }

        // Request account access
        const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });
        const account = accounts[0];
        
        // Initialize provider and signer
        const provider = new ethers.providers.Web3Provider(window.ethereum);
        const signer = provider.getSigner();
        
        // Get network info
        const network = await provider.getNetwork();
        
        // Update state
        state.provider = provider;
        state.signer = signer;
        state.account = account;
        state.chainId = network.chainId;
        state.isConnected = true;
        
        // Update UI
        updateConnectionUI();
        showMessage('connection-message', 'Connected to MetaMask!', 'success');
        
        // Setup event listeners
        setupEventListeners();
        
        // Fetch initial balances
        await updateBalances();
        
        return signer;
      } catch (error) {
        console.error('Failed to connect to MetaMask:', error);
        showMessage('connection-message', `Error connecting: ${error.message}`, 'error');
        throw error;
      }
    }

    function updateConnectionUI() {
      if (state.isConnected) {
        elements.connectionStatus.textContent = 'Connected';
        elements.walletAddress.textContent = state.account;
        elements.chainId.textContent = state.chainId;
        elements.connectWallet.textContent = 'Disconnect';
      } else {
        elements.connectionStatus.textContent = 'Not connected';
        elements.walletAddress.textContent = '-';
        elements.chainId.textContent = '-';
        elements.connectWallet.textContent = 'Connect MetaMask';
      }
    }

    function setupEventListeners() {
      if (window.ethereum) {
        window.ethereum.on('accountsChanged', handleAccountsChanged);
        window.ethereum.on('chainChanged', handleChainChanged);
      }
    }

    function removeEventListeners() {
      if (window.ethereum) {
        window.ethereum.removeListener('accountsChanged', handleAccountsChanged);
        window.ethereum.removeListener('chainChanged', handleChainChanged);
      }
    }

    function handleAccountsChanged(accounts) {
      if (accounts.length === 0) {
        // User disconnected
        disconnectWallet();
      } else {
        // Account changed
        state.account = accounts[0];
        updateConnectionUI();
        updateBalances();
      }
    }

    function handleChainChanged() {
      // Reload the page on chain change as recommended by MetaMask
      window.location.reload();
    }

    function disconnectWallet() {
      // Note: MetaMask doesn't support programmatic disconnect
      // We can only clear our app state
      state.provider = null;
      state.signer = null;
      state.account = null;
      state.chainId = null;
      state.isConnected = false;
      
      // Stop auto-refresh if active
      stopAutoRefresh();
      
      // Remove event listeners
      removeEventListeners();
      
      // Update UI
      updateConnectionUI();
      showMessage('connection-message', 'Disconnected from MetaMask', 'info');
      
      // Clear balances
      resetBalancesUI();
    }

    // Balance Management Functions
    async function getTokenBalance(tokenAddress, userAddress, provider) {
      try {
        const contract = new ethers.Contract(tokenAddress, ['function balanceOf(address) view returns (uint256)'], provider);
        const balance = await contract.balanceOf(userAddress);
        return balance;
      } catch (err) {
        console.error('Error fetching token balance:', err);
        return ethers.BigNumber.from(0);
      }
    }

    async function updateBalances() {
      if (!state.isConnected) {
        showMessage('balance-message', 'Connect wallet first', 'warning');
        return;
      }
      
      try {
        showMessage('balance-message', 'Fetching balances...', 'info');
        console.log('üîç Starting updateBalances...');
        
        const provider = state.provider;
        const userAddress = state.account;

        // Get all balances in parallel
        const [
          currencyWallet,
          companyWallet,
          currencyYes,
          currencyNo,
          companyYes,
          companyNo
        ] = await Promise.all([
          getTokenBalance(TOKEN_CONFIG.currency.address, userAddress, provider),
          getTokenBalance(TOKEN_CONFIG.company.address, userAddress, provider),
          getTokenBalance(TOKEN_CONFIG.currency.getTokenAddresses(true).yes, userAddress, provider),
          getTokenBalance(TOKEN_CONFIG.currency.getTokenAddresses(false).no, userAddress, provider),
          getTokenBalance(TOKEN_CONFIG.company.getTokenAddresses(true).yes, userAddress, provider),
          getTokenBalance(TOKEN_CONFIG.company.getTokenAddresses(false).no, userAddress, provider)
        ]);

        console.log('üîç Raw balances fetched:', {
          currencyWallet: currencyWallet.toString(),
          companyWallet: companyWallet.toString(),
          currencyYes: currencyYes.toString(),
          currencyNo: currencyNo.toString(),
          companyYes: companyYes.toString(),
          companyNo: companyNo.toString()
        });

        // Format all balances
        const formatBalance = (balance, decimals) => ({
          amount: balance.toString(),
          formatted: ethers.utils.formatUnits(balance, decimals)
        });

        const currencyYesFormatted = ethers.utils.formatUnits(currencyYes, TOKEN_CONFIG.currency.decimals);
        const currencyNoFormatted = ethers.utils.formatUnits(currencyNo, TOKEN_CONFIG.currency.decimals);
        const companyYesFormatted = ethers.utils.formatUnits(companyYes, TOKEN_CONFIG.company.decimals);
        const companyNoFormatted = ethers.utils.formatUnits(companyNo, TOKEN_CONFIG.company.decimals);

        console.log('üîç Formatted balances:', {
          currencyYesFormatted,
          currencyNoFormatted,
          companyYesFormatted,
          companyNoFormatted
        });

        // Update state
        state.balances = {
          currency: {
            wallet: formatBalance(currencyWallet, TOKEN_CONFIG.currency.decimals),
            collateral: {
              yes: currencyYesFormatted,
              no: currencyNoFormatted,
              ...calculatePositionInfo(currencyYesFormatted, currencyNoFormatted)
            }
          },
          company: {
            wallet: formatBalance(companyWallet, TOKEN_CONFIG.company.decimals),
            collateral: {
              yes: companyYesFormatted,
              no: companyNoFormatted,
              ...calculatePositionInfo(companyYesFormatted, companyNoFormatted)
            }
          }
        };

        console.log('üîç state.balances updated:', JSON.stringify(state.balances, null, 2));

        // Update UI
        updateBalancesUI();
        showMessage('balance-message', 'Balances updated!', 'success');
      } catch (err) {
        console.error('Error updating balances:', err);
        showMessage('balance-message', `Error: ${err.message}`, 'error');
      }
    }

    function updateBalancesUI() {
      // Currency token
      elements.currencyWalletBalance.textContent = state.balances.currency.wallet.formatted;
      elements.currencyYesBalance.textContent = state.balances.currency.collateral.yes;
      elements.currencyNoBalance.textContent = state.balances.currency.collateral.no;
      elements.currencyTotalPosition.textContent = state.balances.currency.collateral.total.toFixed(6);
      
      // Format currency position outcome - "IF NO RECOVER X.XX" (absolute value of negative net position)
      const currencyNetPos = state.balances.currency.collateral.netPosition;
      if (currencyNetPos < 0) {
        elements.currencyPositionOutcome.textContent = `IF NO RECOVER ${Math.abs(currencyNetPos).toFixed(6)}`;
      } else if (currencyNetPos > 0) {
        elements.currencyPositionOutcome.textContent = `IF YES RECOVER ${currencyNetPos.toFixed(6)}`;
      } else {
        elements.currencyPositionOutcome.textContent = `IF NO RECOVER 0.0`;
      }
      
      // Company token
      elements.companyWalletBalance.textContent = state.balances.company.wallet.formatted;
      elements.companyYesBalance.textContent = state.balances.company.collateral.yes;
      elements.companyNoBalance.textContent = state.balances.company.collateral.no;
      elements.companyTotalPosition.textContent = state.balances.company.collateral.total.toFixed(6);
      
      // Format company position outcome - "IF YES/NO RECEIVE X.XX"
      const companyNetPos = state.balances.company.collateral.netPosition;
      if (companyNetPos > 0) {
        elements.companyPositionOutcome.textContent = `IF YES RECEIVE ${companyNetPos.toFixed(6)}`;
      } else if (companyNetPos < 0) {
        elements.companyPositionOutcome.textContent = `IF NO RECEIVE ${Math.abs(companyNetPos).toFixed(6)}`;
      } else {
        elements.companyPositionOutcome.textContent = `IF YES RECEIVE 0.0`;
      }
    }

    function resetBalancesUI() {
      // Reset all balance displays to 0
      elements.currencyWalletBalance.textContent = '0';
      elements.currencyYesBalance.textContent = '0';
      elements.currencyNoBalance.textContent = '0';
      elements.currencyTotalPosition.textContent = '0';
      elements.currencyPositionOutcome.textContent = 'IF NO RECOVER 0.0';
      
      elements.companyWalletBalance.textContent = '0';
      elements.companyYesBalance.textContent = '0';
      elements.companyNoBalance.textContent = '0';
      elements.companyTotalPosition.textContent = '0';
      elements.companyPositionOutcome.textContent = 'IF YES RECEIVE 0.0';
    }

    function startAutoRefresh(intervalMs = TRANSACTION_SETTINGS.REFRESH_INTERVAL_MS) {
      const safeInterval = Math.max(1000, intervalMs);
      
      if (state.refreshInterval) {
        clearInterval(state.refreshInterval);
      }

      try {
        state.refreshInterval = setInterval(updateBalances, safeInterval);
        state.isAutoRefreshing = true;
        elements.autoRefreshToggle.textContent = 'Stop Auto-Refresh';
        return true;
      } catch (err) {
        console.error('Error starting auto-refresh:', err);
        return false;
      }
    }

    function stopAutoRefresh() {
      if (state.refreshInterval) {
        clearInterval(state.refreshInterval);
        state.refreshInterval = null;
      }
      state.isAutoRefreshing = false;
      elements.autoRefreshToggle.textContent = 'Start Auto-Refresh';
    }

    // Token Approval Functions
    async function approveToken(tokenType) {
      if (!state.isConnected) {
        showMessage('approval-message', 'Connect wallet first', 'warning');
        return;
      }
      
      const tokenAddress = TOKEN_CONFIG[tokenType].address;
      const spenderAddress = CONTRACT_ADDRESSES.futarchyRouter;
      
      try {
        // Update state
        state.isApproving[tokenType] = true;
        
        // Update UI
        const buttonElement = tokenType === 'currency' ? elements.approveCurrency : elements.approveCompany;
        const originalText = buttonElement.textContent;
        buttonElement.textContent = 'Approving...';
        buttonElement.disabled = true;
        
        showMessage('approval-message', `${STATUS_MESSAGES.APPROVING_TOKEN} (${tokenType})`, 'info');
        
        // Get signer
        const signer = state.signer;
        
        // Create contract instance
        const tokenContract = new ethers.Contract(tokenAddress, ERC20_ABI, signer);
        
        // Approve max uint256
        const maxUint256 = ethers.constants.MaxUint256;
        const tx = await tokenContract.approve(spenderAddress, maxUint256, {
          gasLimit: TRANSACTION_SETTINGS.DEFAULT_GAS_LIMIT,
          type: TRANSACTION_SETTINGS.TRANSACTION_TYPE,
          maxFeePerGas: TRANSACTION_SETTINGS.MAX_FEE_PER_GAS,
          maxPriorityFeePerGas: TRANSACTION_SETTINGS.MAX_PRIORITY_FEE_PER_GAS
        });
        
        showMessage('approval-message', `${STATUS_MESSAGES.WAITING_CONFIRMATION} (${tokenType})`, 'info');
        
        // Wait for transaction confirmation
        await tx.wait();
        
        // Update transaction history
        addTransactionToHistory(tx.hash, `Approved ${TOKEN_CONFIG[tokenType].name} token`);
        
        // Update UI
        showMessage('approval-message', `${STATUS_MESSAGES.TRANSACTION_CONFIRMED} (${tokenType})`, 'success');
        
        return tx;
      } catch (error) {
        console.error('Approval failed:', error);
        showMessage('approval-message', `Error: ${handleTransactionError(error)}`, 'error');
        throw error;
      } finally {
        // Update state
        state.isApproving[tokenType] = false;
        
        // Update UI
        const buttonElement = tokenType === 'currency' ? elements.approveCurrency : elements.approveCompany;
        buttonElement.textContent = `Approve ${tokenType.charAt(0).toUpperCase() + tokenType.slice(1)} Token`;
        buttonElement.disabled = false;
      }
    }

    // Token Swap Functions
    async function executeSwap(tokenType, isBuy, amount, isYesToken = true) {
      console.log('üîÑ Executing swap:', { tokenType, isBuy, amount, isYesToken });
      if (!state.isConnected) {
        showMessage('swap-message', 'Connect wallet first', 'warning');
        return;
      }
      
      if (!amount || isNaN(amount) || parseFloat(amount) <= 0) {
        showMessage('swap-message', ERROR_MESSAGES.INVALID_AMOUNT, 'error');
        return;
      }
      
      try {
        state.isSwapping = true;
        
        // Update UI to show loading state
        const tokenTypeText = isYesToken ? "YES" : "NO";
        showMessage('swap-message', `${STATUS_MESSAGES.PREPARING_TRANSACTION} (${tokenType} ${isBuy ? 'buy' : 'sell'} ${tokenTypeText})`, 'info');
        
        const signer = state.signer;
        const userAddress = await signer.getAddress();
        
        // Determine which tokens to use in the swap
        // Use isYesToken parameter to set eventHappens value
        const eventHappens = isYesToken;
        
        // Determine tokens for swap
        let tokenIn, tokenOut;
        
        if (isBuy) {
          // FIXED LOGIC: Always use YES/NO tokens for buying operations
          console.log('Buy operation - using position tokens for trading');
          
          // Use YES/NO tokens as input for buying
          tokenIn = tokenType === 'currency'
            ? TOKEN_CONFIG.currency.getTokenAddresses(eventHappens)[isYesToken ? 'yes' : 'no']
            : TOKEN_CONFIG.company.getTokenAddresses(eventHappens)[isYesToken ? 'yes' : 'no'];
          
          tokenOut = tokenType === 'currency'
            ? TOKEN_CONFIG.currency.getTokenAddresses(eventHappens)[isYesToken ? 'yes' : 'no']
            : TOKEN_CONFIG.company.getTokenAddresses(eventHappens)[isYesToken ? 'yes' : 'no'];
        } else {
          // Selling tokens: use outcome tokens ‚Üí base currency
          tokenIn = tokenType === 'currency'
            ? TOKEN_CONFIG.currency.getTokenAddresses(eventHappens)[isYesToken ? 'yes' : 'no']
            : TOKEN_CONFIG.company.getTokenAddresses(eventHappens)[isYesToken ? 'yes' : 'no'];
          
          tokenOut = tokenType === 'currency'
            ? TOKEN_CONFIG.currency.address
            : TOKEN_CONFIG.company.address;
        }
        
        // ADD DETAILED LOGGING FOR TOKEN ADDRESSES
        console.log('=== SWAP TOKEN DETAILED DEBUGGING ===');
        console.log('Operation Type:', isBuy ? 'BUY' : 'SELL');
        console.log('Token Type:', tokenType);
        console.log('Is YES Token:', isYesToken);
        console.log('Event Happens:', eventHappens);
        console.log('Token Config:', TOKEN_CONFIG);
        console.log('Base Token Address:', tokenType === 'currency' ? TOKEN_CONFIG.currency.address : TOKEN_CONFIG.company.address);
        console.log('YES Token Address:', tokenType === 'currency' 
          ? TOKEN_CONFIG.currency.getTokenAddresses(eventHappens).yes 
          : TOKEN_CONFIG.company.getTokenAddresses(eventHappens).yes);
          
        console.log('NO Token Address:', tokenType === 'currency' 
          ? TOKEN_CONFIG.currency.getTokenAddresses(eventHappens).no 
          : TOKEN_CONFIG.company.getTokenAddresses(eventHappens).no);
          
        console.log('TokenIn Address:', tokenIn);
        console.log('TokenOut Address:', tokenOut);
        console.log('TokenIn is Position Token:', tokenIn !== TOKEN_CONFIG.currency.address && tokenIn !== TOKEN_CONFIG.company.address);
        console.log('======================================');
        
        // Parse amount to BigNumber with correct decimals
        const parsedAmount = parseTokenAmount(amount, TOKEN_CONFIG[tokenType].decimals);
        
        // Get current position balances
        const yesTokenAddress = TOKEN_CONFIG[tokenType].getTokenAddresses(true).yes;
        const noTokenAddress = TOKEN_CONFIG[tokenType].getTokenAddresses(false).no;
        const baseTokenAddress = TOKEN_CONFIG[tokenType].address;
        
        const yesTokenContract = new ethers.Contract(yesTokenAddress, ERC20_ABI, signer);
        const noTokenContract = new ethers.Contract(noTokenAddress, ERC20_ABI, signer);
        const baseTokenContract = new ethers.Contract(baseTokenAddress, ERC20_ABI, signer);
        
        const yesBalance = await yesTokenContract.balanceOf(userAddress);
        const noBalance = await noTokenContract.balanceOf(userAddress);
        const baseBalance = await baseTokenContract.balanceOf(userAddress);
        
        // Determine which token we need to check based on the operation
        let tokenToCheck, balanceToCheck;
        
        if (isBuy) {
          // For buying, we need base token
          tokenToCheck = baseTokenAddress;
          balanceToCheck = baseBalance;
        } else {
          // For selling, we need the specific YES/NO token
          if (isYesToken) {
            tokenToCheck = yesTokenAddress;
            balanceToCheck = yesBalance;
          } else {
            tokenToCheck = noTokenAddress;
            balanceToCheck = noBalance;
          }
        }
        
        // Log the balance check details for debugging
        console.log('Smart balance check for swap:', {
          tokenType,
          isBuy,
          isYesToken,
          tokenIn,
          tokenOut,
          yesBalance: ethers.utils.formatUnits(yesBalance, 18),
          noBalance: ethers.utils.formatUnits(noBalance, 18),
          baseBalance: ethers.utils.formatUnits(baseBalance, 18),
          tokenToCheck,
          balanceToCheck: ethers.utils.formatUnits(balanceToCheck, 18),
          parsedAmount: ethers.utils.formatUnits(parsedAmount, 18),
          hasEnoughBalance: balanceToCheck.gte(parsedAmount)
        });
        
        // Check if we need to add collateral
        // For both buy and sell operations, we might need to add collateral if wallet + position < requested amount
        const walletBalance = isBuy ? baseBalance : (isYesToken ? yesBalance : noBalance);
        
        // FIXED: When buying, the position balance should be the YES/NO token balance
        // When selling, the position balance is the YES/NO token balance
        let positionBalance;
        if (isBuy) {
          // For buy operations, position balance is the YES/NO token balance we already have
          positionBalance = isYesToken ? yesBalance : noBalance;
        } else {
          // For sell operations, we're selling YES/NO tokens, so check those balances
          positionBalance = isYesToken ? yesBalance : noBalance;
        }
        
        // Calculate total available using BigNumber
        const totalAvailable = walletBalance.add(positionBalance);
        
        console.log('Collateral check:', {
          tokenType,
          isBuy,
          isYesToken,
          walletBalance: ethers.utils.formatUnits(walletBalance, 18),
          positionBalance: ethers.utils.formatUnits(positionBalance, 18),
          totalAvailable: ethers.utils.formatUnits(totalAvailable, 18),
          requestedAmount: ethers.utils.formatUnits(parsedAmount, 18)
        });
        
        // If total available is less than requested amount, show error
        if (totalAvailable.lt(parsedAmount)) {
          showMessage('swap-message', `${ERROR_MESSAGES.INSUFFICIENT_BALANCE} - Need ${ethers.utils.formatUnits(parsedAmount, 18)} but have ${ethers.utils.formatUnits(totalAvailable, 18)} total`, 'error');
          return;
        }
        
        // In sell mode, if position balance is insufficient but wallet has funds, we need to add collateral
        // In buy mode, we need to add collateral if position balance is insufficient
        let needsCollateral = false;

        if (isBuy) {
          // When buying, check if we already have enough YES/NO tokens
          needsCollateral = positionBalance.lt(parsedAmount);
          console.log(`Buy operation - needsCollateral: ${needsCollateral}`);
        } else {
          // When selling, if our position balance is less than requested amount, we need to add collateral
          needsCollateral = positionBalance.lt(parsedAmount);
          console.log(`Sell operation - needsCollateral: ${needsCollateral}`);
        }
        
        // If we need to add collateral
        if (needsCollateral) {
          // Calculate additional collateral needed
          const additionalCollateralNeeded = parsedAmount.sub(positionBalance);
          console.log('Additional collateral needed:', ethers.utils.formatUnits(additionalCollateralNeeded, 18));
          
          let additionalNeeded = additionalCollateralNeeded;
          
          // Different logic based on buy/sell
          if (isBuy) {
            console.log('Buy operation - need to add collateral to get YES/NO tokens!');
          } else {
            console.log('Sell operation with insufficient position balance - need to add collateral!');
          }
          
          // Add detailed logging for collateral addition
          console.log('=== COLLATERAL ADDITION DEBUGGING ===');
          console.log('Operation:', isBuy ? 'BUY' : 'SELL');
          console.log('Token Type:', tokenType);
          console.log('Position Type:', isYesToken ? 'YES' : 'NO');
          console.log('Base Token Address:', baseTokenAddress);
          console.log('YES Token Address:', yesTokenAddress);
          console.log('NO Token Address:', noTokenAddress);
          console.log('Position Balance:', ethers.utils.formatUnits(positionBalance, 18));
          console.log('Requested Amount:', ethers.utils.formatUnits(parsedAmount, 18));
          console.log('Additional Collateral Needed:', ethers.utils.formatUnits(additionalNeeded, 18));
          console.log('===================================');
          
          // Update UI
          showMessage('swap-message', `Adding ${ethers.utils.formatUnits(additionalNeeded, 18)} as collateral...`, 'info');
          updateSwapStep(2, 'In Progress', 'Adding collateral');
          
          try {
            // Add collateral
            console.log('Calling addCollateral with:', {
              tokenType,
              amount: ethers.utils.formatUnits(additionalNeeded, 18),
              isYesToken
            });
            
            const didAddCollateral = await addCollateral(tokenType, ethers.utils.formatUnits(additionalNeeded, 18), isYesToken);
            
            // If addCollateral failed, stop here
            if (!didAddCollateral) {
              console.error('Failed to add collateral');
              updateSwapStep(2, 'Failed', 'Failed to add collateral');
              return;
            }
            
            console.log('=== COLLATERAL ADDED SUCCESSFULLY ===');
            console.log('Amount Added:', ethers.utils.formatUnits(additionalNeeded, 18));
            console.log('Token Type:', tokenType);
            console.log('Position Type:', isYesToken ? 'YES' : 'NO');
            console.log('=====================================');
            
            // Update UI
            updateSwapStep(2, 'Complete', 'Collateral added');
            showMessage('swap-message', 'Collateral added, proceeding with swap...', 'success');
            
            // CRITICAL: Update balances and refresh the position balance
            await updateBalances();
            
            // Refresh the balance check with updated balances
            // We need to update yesBalance, noBalance, baseBalance after adding collateral
            const userAddress = await signer.getAddress();
            const yesTokenContract = new ethers.Contract(yesTokenAddress, ERC20_ABI, signer);
            const noTokenContract = new ethers.Contract(noTokenAddress, ERC20_ABI, signer);
            const baseTokenContract = new ethers.Contract(baseTokenAddress, ERC20_ABI, signer);

            yesBalance = await yesTokenContract.balanceOf(userAddress);
            noBalance = await noTokenContract.balanceOf(userAddress);
            baseBalance = await baseTokenContract.balanceOf(userAddress);
            
            // Update positionBalance with new values
            if (isBuy) {
              positionBalance = isYesToken ? yesBalance : noBalance;
            } else {
              positionBalance = isYesToken ? yesBalance : noBalance;
            }
            
            console.log('Updated balances after adding collateral:', {
              yesBalance: ethers.utils.formatUnits(yesBalance, 18),
              noBalance: ethers.utils.formatUnits(noBalance, 18),
              baseBalance: ethers.utils.formatUnits(baseBalance, 18),
              positionBalance: ethers.utils.formatUnits(positionBalance, 18)
            });
            
            // Now check if we have enough after adding collateral
            if (positionBalance.lt(parsedAmount)) {
              console.warn(`Position balance still insufficient after adding collateral. This could be due to a delay in balance updates. Attempting swap anyway...`);
              
              // We'll continue with the swap, as the collateral addition might take time to reflect in the balance
              // If the collateral wasn't actually added successfully, the swap will fail at the contract level
            }
          } catch (error) {
            console.error('Error adding collateral:', error);
            showMessage('swap-message', `Error adding collateral: ${error.message}`, 'error');
            updateSwapStep(2, 'Failed', 'Failed to add collateral');
            return;
          }
        } else {
          // Skip collateral step
          updateSwapStep(2, 'Skipped', 'No additional collateral needed');
          console.log('Collateral addition skipped - sufficient balance already available');
        }
        
        // Log swap details
        console.log('Executing V3 swap:', {
          tokenType,
          isBuy,
          tokenIn,
          tokenOut,
          amount: parsedAmount.toString(),
          eventHappens
        });
        
        // Right before token approval, add detailed logging
        console.log('=== TOKEN APPROVAL DEBUGGING ===');
        console.log('About to check and approve token for swap:');
        console.log('- Token to approve (tokenIn):', tokenIn);
        console.log('- Look up the address above in the token addresses to verify it\'s correct');
        console.log('- For BUY: Should be approving base token');
        console.log('- For SELL: Should be approving YES/NO position token');
        console.log('- Amount to approve:', ethers.utils.formatUnits(parsedAmount, 18));
        console.log('==============================');
        
        // Log balances before the swap
        console.log('=== BALANCES BEFORE SWAP ===');
        console.log('Base Token Balance:', ethers.utils.formatUnits(baseBalance, 18));
        console.log('YES Token Balance:', ethers.utils.formatUnits(yesBalance, 18));
        console.log('NO Token Balance:', ethers.utils.formatUnits(noBalance, 18));
        console.log('Token Being Used (tokenIn):', tokenIn);
        console.log('Is Using Position Token:', tokenIn !== baseTokenAddress);
        console.log('===========================');
        
        await checkAndApproveTokenForV3Swap({
          signer,
          tokenAddress: tokenIn,
          amount: parsedAmount,
          eventHappens,
          onApprovalNeeded: () => {
            showMessage('swap-message', 'Approving token for SushiSwap V3...', 'info');
            console.log('Approval needed for token:', tokenIn);
          },
          onApprovalComplete: () => {
            showMessage('swap-message', 'Token approved for SushiSwap V3', 'success');
            console.log('Approval completed for token:', tokenIn);
          }
        });
        
        // After approval, log that we're moving to the swap
        console.log('=== APPROVAL COMPLETED, PROCEEDING TO SWAP ===');
        console.log('- TokenIn:', tokenIn);
        console.log('- TokenOut:', tokenOut);
        console.log('- Amount:', ethers.utils.formatUnits(parsedAmount, 18));
        console.log('===============================================');
        
        // Execute the swap
        showMessage('swap-message', 'Executing V3 swap...', 'info');
        
        const swapTx = await executeV3Swap({
          signer,
          tokenIn,
          tokenOut,
          amount: parsedAmount,
          eventHappens,
          options: {
            gasLimit: TRANSACTION_SETTINGS.DEFAULT_GAS_LIMIT
          }
        });
        
        showMessage('swap-message', STATUS_MESSAGES.WAITING_CONFIRMATION, 'info');
        
        // Wait for confirmation
        await swapTx.wait();
        
        // Add transaction to history
        const operation = isBuy ? 'Bought' : 'Sold';
        addTransactionToHistory(swapTx.hash, `${operation} ${amount} ${tokenType.toUpperCase()} ${eventHappens ? 'YES' : 'NO'} tokens via SushiSwap V3`);
        
        // Update balances
        console.log('Refreshing balances after swap completion...');
        await updateBalances();
        
        // Get the latest balances to compare with before
        const updatedYesBalance = await yesTokenContract.balanceOf(userAddress);
        const updatedNoBalance = await noTokenContract.balanceOf(userAddress);
        const updatedBaseBalance = await baseTokenContract.balanceOf(userAddress);
        
        // Log the updated balances
        console.log('=== BALANCES AFTER SWAP ===');
        console.log('Base Token Balance:', ethers.utils.formatUnits(updatedBaseBalance, 18));
        console.log('YES Token Balance:', ethers.utils.formatUnits(updatedYesBalance, 18));
        console.log('NO Token Balance:', ethers.utils.formatUnits(updatedNoBalance, 18));
        console.log('==========================');
        
        // Calculate the differences
        const baseDiff = updatedBaseBalance.sub(baseBalance);
        const yesDiff = updatedYesBalance.sub(yesBalance);
        const noDiff = updatedNoBalance.sub(noBalance);
        
        console.log('=== BALANCE CHANGES ===');
        console.log('Base Token Change:', ethers.utils.formatUnits(baseDiff, 18), baseDiff.gte(0) ? '(+)' : '(-)');
        console.log('YES Token Change:', ethers.utils.formatUnits(yesDiff, 18), yesDiff.gte(0) ? '(+)' : '(-)');
        console.log('NO Token Change:', ethers.utils.formatUnits(noDiff, 18), noDiff.gte(0) ? '(+)' : '(-)');
        console.log('======================');
        
        // Update UI to show success
        showMessage('swap-message', STATUS_MESSAGES.TRANSACTION_CONFIRMED, 'success');
        
        return swapTx;
      } catch (error) {
        console.error('Swap failed:', error);
        showMessage('swap-message', `Error: ${handleTransactionError(error)}`, 'error');
        throw error;
      } finally {
        state.isSwapping = false;
      }
    }

    /**
     * Helper function to get the correct checksum address
     * This uses ethers.js utils.getAddress to convert an address to the correct checksum format
     */
    function getChecksumAddress(address) {
      // Handle undefined or null addresses
      if (!address) {
        console.error('‚ùå Cannot get checksum for undefined/null address');
        return null;  // Return null to make the error more obvious
      }
      
      try {
        // First try with the original address
        return ethers.utils.getAddress(address);
      } catch (error) {
        // If that fails, try with lowercase
        try {
          console.warn('‚ö†Ô∏è Trying with lowercase address instead:', address.toLowerCase());
          return ethers.utils.getAddress(address.toLowerCase());
        } catch (innerError) {
          console.error('‚ùå Error getting checksum address for', address, ':', error);
          // Return the original address if there's an error
          return address;
        }
      }
    }

    // Collateral Split and Merge Functions
    async function addCollateral(tokenType, amount, isYes = undefined) {
      console.log('=== ADD COLLATERAL FUNCTION ENTRY ===');
      console.log('Token Type:', tokenType);
      console.log('Amount:', amount);
      console.log('Is YES position:', isYes, '(parameter is optional)');
      console.log('=====================================');
      
      if (!state.isConnected) {
        showMessage('collateral-message', 'Connect wallet first', 'warning');
        console.log('Error: Wallet not connected');
        return false;
      }
      
      if (!amount || isNaN(amount) || parseFloat(amount) <= 0) {
        showMessage('collateral-message', ERROR_MESSAGES.INVALID_AMOUNT, 'error');
        console.log('Error: Invalid amount', amount);
        return false;
      }
      
      try {
        // Determine if tokenType is an address or a token type string
        let tokenAddress;
        let tokenSymbol;
        
        // Handle case when tokenType is an address
        if (tokenType === TOKEN_CONFIG.currency.address) {
          console.log('Converting token address to currency type');
          tokenType = 'currency';
        } else if (tokenType === TOKEN_CONFIG.company.address) {
          console.log('Converting token address to company type');
          tokenType = 'company';
        }
        
        // Now tokenType should be 'currency' or 'company'
        tokenAddress = TOKEN_CONFIG[tokenType].address;
        tokenSymbol = TOKEN_CONFIG[tokenType].symbol;
        
        console.log('Resolved token details:', {
          type: tokenType,
          address: tokenAddress,
          symbol: tokenSymbol
        });
        
        showMessage('collateral-message', `Preparing to add collateral...`, 'info');
        
        const signer = state.signer;
        const userAddress = await signer.getAddress();
        
        // Create contract instances
        const tokenContract = new ethers.Contract(tokenAddress, ERC20_ABI, signer);
        
        // Check user balance
        const userBalance = await tokenContract.balanceOf(userAddress);
        const parsedAmount = typeof amount === 'object' ? amount : parseTokenAmount(amount, 18);
        
        console.log('Balance check for collateral:', {
          userAddress,
          tokenAddress,
          userBalance: ethers.utils.formatUnits(userBalance, 18),
          requestedAmount: typeof amount === 'object' ? amount.toString() : amount,
          parsedAmount: parsedAmount.toString(),
          hasEnoughBalance: userBalance.gte(parsedAmount)
        });
        
        if (userBalance.lt(parsedAmount)) {
          showMessage('collateral-message', ERROR_MESSAGES.INSUFFICIENT_BALANCE, 'error');
          console.log('Error: Insufficient balance for collateral');
          return false;
        }
        
        // Check token allowance for futarchy router
        const routerAddress = CONTRACT_ADDRESSES.futarchyRouter;
        const currentAllowance = await tokenContract.allowance(userAddress, routerAddress);
        
        console.log('=== COLLATERAL TOKEN APPROVAL CHECK ===');
        console.log('Token:', tokenAddress, tokenSymbol);
        console.log('Router Address:', routerAddress);
        console.log('Current Allowance:', ethers.utils.formatUnits(currentAllowance, 18));
        console.log('Required Amount:', ethers.utils.formatUnits(parsedAmount, 18));
        console.log('Approval Needed:', currentAllowance.lt(parsedAmount));
        console.log('=======================================');
        
        // If allowance is insufficient, approve tokens
        if (currentAllowance.lt(parsedAmount)) {
          showMessage('collateral-message', STATUS_MESSAGES.APPROVING_TOKEN, 'info');
          console.log('Insufficient allowance, approving token...');
          
          const approveTx = await tokenContract.approve(routerAddress, ethers.constants.MaxUint256);
          console.log('Approval transaction submitted:', approveTx.hash);
          showMessage('collateral-message', `Waiting for approval confirmation...`, 'info');
          
          await approveTx.wait();
          console.log('Approval confirmed for collateral token');
          
          // Add approval transaction to history
          addTransactionToHistory(approveTx.hash, `Approved ${tokenSymbol} for adding collateral`);
        } else {
          console.log('Token already approved for the router, skipping approval');
        }
        
        // Create futarchy router contract instance with ABI
        const futarchyAbi = [
          {
            "inputs": [
              {
                "internalType": "contract FutarchyProposal",
                "name": "proposal",
                "type": "address"
              },
              {
                "internalType": "contract IERC20",
                "name": "collateralToken",
                "type": "address"
              },
              {
                "internalType": "uint256",
                "name": "amount",
                "type": "uint256"
              }
            ],
            "name": "splitPosition",
            "outputs": [],
            "stateMutability": "nonpayable",
            "type": "function"
          }
        ];
        
        const routerContract = new ethers.Contract(routerAddress, futarchyAbi, signer);
        
        // Use the market address directly - this is simpler and more reliable
        const collectionAddress = CONTRACT_ADDRESSES.market;
        console.log('Using market address as collection address:', collectionAddress);
        
        // Log all available addresses for debugging
        console.log('Available contract addresses:', {
          market: CONTRACT_ADDRESSES.market,
          futarchyRouter: CONTRACT_ADDRESSES.futarchyRouter,
          baseTokenAddress: tokenAddress
        });
        
        // Ensure the address is checksummed
        const checksumCollectionAddress = getChecksumAddress(collectionAddress);
        
        // Get the correct collateral token address (ensure it's checksummed)
        const collateralTokenAddress = getChecksumAddress(tokenAddress);

        console.log('=== EXECUTING SPLIT POSITION ===');
        console.log('Router Address:', routerAddress);
        console.log('Collection Address:', checksumCollectionAddress);
        console.log('Collateral Token Address:', collateralTokenAddress);
        console.log('Amount (parsed):', parsedAmount.toString());
        console.log('Amount (formatted):', ethers.utils.formatUnits(parsedAmount, 18));
        console.log('===============================');
        
        // Check if we have valid addresses
        if (!checksumCollectionAddress) {
          console.error('Invalid collection address');
          showMessage('collateral-message', 'Error: Invalid market address', 'error');
          return false;
        }
        
        if (!collateralTokenAddress) {
          console.error('Invalid collateral token address');
          showMessage('collateral-message', 'Error: Invalid token address', 'error');
          return false;
        }
        
        showMessage('collateral-message', `Adding ${ethers.utils.formatUnits(parsedAmount, 18)} as collateral...`, 'info');
        
        // Call splitPosition function
        const splitTx = await routerContract.splitPosition(
          checksumCollectionAddress,
          collateralTokenAddress,
          parsedAmount,
          {
            gasLimit: TRANSACTION_SETTINGS.DEFAULT_GAS_LIMIT,
            type: TRANSACTION_SETTINGS.TRANSACTION_TYPE,
            maxFeePerGas: TRANSACTION_SETTINGS.MAX_FEE_PER_GAS,
            maxPriorityFeePerGas: TRANSACTION_SETTINGS.MAX_PRIORITY_FEE_PER_GAS
          }
        );
        
        showMessage('collateral-message', STATUS_MESSAGES.WAITING_CONFIRMATION, 'info');
        console.log('Split transaction submitted:', splitTx.hash);
        
        // Wait for confirmation
        await splitTx.wait();
        console.log('Split transaction confirmed!');
        
        // Add transaction to history
        let amountDisplay;
        if (typeof amount === 'object' && amount._isBigNumber) {
          // Format the BigNumber without rounding
          amountDisplay = ethers.utils.formatEther(amount);
        } else {
          // Use the original string amount
          amountDisplay = amount;
        }
        addTransactionToHistory(splitTx.hash, `Added ${amountDisplay} as collateral`);
        
        // Update balances
        await updateBalances();
        
        // Update UI to show success
        showMessage('collateral-message', 'Collateral successfully added', 'success');
        console.log('Collateral addition completed successfully');
        
        // Return true to indicate success
        return true;
      } catch (error) {
        console.error('=== ERROR ADDING COLLATERAL ===');
        console.error('Error details:', error);
        console.error('Token Type:', tokenType);
        console.error('Amount:', amount);
        console.error('Is YES position:', isYes);
        console.error('================================');
        
        showMessage('collateral-message', `${ERROR_MESSAGES.SPLIT_ERROR}: ${error.message}`, 'error');
        return false;
      }
    }
    
    async function removeCollateral(tokenType, amount) {
      if (!state.isConnected) {
        showMessage('collateral-message', 'Connect wallet first', 'warning');
        return;
      }
      
      if (!amount || isNaN(amount) || parseFloat(amount) <= 0) {
        showMessage('collateral-message', ERROR_MESSAGES.INVALID_AMOUNT, 'error');
        return;
      }
      
      try {
        showMessage('collateral-message', `Preparing to remove collateral...`, 'info');
        
        const signer = state.signer;
        const userAddress = await signer.getAddress();
        
        // Get token addresses
        const yesTokenAddress = TOKEN_CONFIG[tokenType].getTokenAddresses(true).yes;
        const noTokenAddress = TOKEN_CONFIG[tokenType].getTokenAddresses(false).no;
        
        // Create contract instances
        const yesTokenContract = new ethers.Contract(yesTokenAddress, ERC20_ABI, signer);
        const noTokenContract = new ethers.Contract(noTokenAddress, ERC20_ABI, signer);
        
        // Check user balance for both YES and NO tokens
        const yesBalance = await yesTokenContract.balanceOf(userAddress);
        const noBalance = await noTokenContract.balanceOf(userAddress);
        
        // Parse amount to BigNumber
        const parsedAmount = parseTokenAmount(amount, TOKEN_CONFIG[tokenType].decimals);
        
        // Check if user has enough of both tokens
        if (yesBalance.lt(parsedAmount) || noBalance.lt(parsedAmount)) {
          showMessage('collateral-message', 'Insufficient YES/NO token balance for merge', 'error');
          return;
        }
        
        // Check token allowances for futarchy router
        const routerAddress = CONTRACT_ADDRESSES.futarchyRouter;
        const yesAllowance = await yesTokenContract.allowance(userAddress, routerAddress);
        const noAllowance = await noTokenContract.allowance(userAddress, routerAddress);
        
        // If YES token allowance is insufficient, approve tokens
        if (yesAllowance.lt(parsedAmount)) {
          showMessage('collateral-message', `Approving YES ${tokenType.toUpperCase()} tokens...`, 'info');
          
          const yesApproveTx = await yesTokenContract.approve(routerAddress, ethers.constants.MaxUint256);
          showMessage('collateral-message', `Waiting for YES token approval...`, 'info');
          
          await yesApproveTx.wait();
          
          // Add approval transaction to history
          addTransactionToHistory(yesApproveTx.hash, `Approved YES ${tokenType.toUpperCase()} tokens for removing collateral`);
        }
        
        // If NO token allowance is insufficient, approve tokens
        if (noAllowance.lt(parsedAmount)) {
          showMessage('collateral-message', `Approving NO ${tokenType.toUpperCase()} tokens...`, 'info');
          
          const noApproveTx = await noTokenContract.approve(routerAddress, ethers.constants.MaxUint256);
          showMessage('collateral-message', `Waiting for NO token approval...`, 'info');
          
          await noApproveTx.wait();
          
          // Add approval transaction to history
          addTransactionToHistory(noApproveTx.hash, `Approved NO ${tokenType.toUpperCase()} tokens for removing collateral`);
        }
        
        // Create futarchy router contract instance with ABI
        const futarchyAbi = [
          {
            "inputs": [
              {
                "internalType": "contract FutarchyProposal",
                "name": "proposal",
                "type": "address"
              },
              {
                "internalType": "contract IERC20",
                "name": "collateralToken",
                "type": "address"
              },
              {
                "internalType": "uint256",
                "name": "amount",
                "type": "uint256"
              }
            ],
            "name": "mergePositions",
            "outputs": [],
            "stateMutability": "nonpayable",
            "type": "function"
          },
          'function mergeCollateral(address collateralToken, uint256 amount) returns (bool)'
        ];
        
        const futarchyContract = new ethers.Contract(routerAddress, futarchyAbi, signer);
        
        // Execute merge
        showMessage('collateral-message', 'Removing collateral...', 'info');
        
        const mergeTx = await futarchyContract.mergePositions(
          CONTRACT_ADDRESSES.market,
          TOKEN_CONFIG[tokenType].address,
          parsedAmount,
          { 
            gasLimit: TRANSACTION_SETTINGS.DEFAULT_GAS_LIMIT,
            type: TRANSACTION_SETTINGS.TRANSACTION_TYPE,
            maxFeePerGas: TRANSACTION_SETTINGS.MAX_FEE_PER_GAS,
            maxPriorityFeePerGas: TRANSACTION_SETTINGS.MAX_PRIORITY_FEE_PER_GAS
          }
        );
        
        showMessage('collateral-message', STATUS_MESSAGES.WAITING_CONFIRMATION, 'info');
        
        // Wait for confirmation
        await mergeTx.wait();
        
        // Add transaction to history
        addTransactionToHistory(mergeTx.hash, `Removed ${amount} ${TOKEN_CONFIG[tokenType].name} collateral`);
        
        // Update balances
        await updateBalances();
        
        showMessage('collateral-message', 'Collateral removed successfully!', 'success');
        
        return mergeTx;
      } catch (error) {
        console.error('Remove collateral failed:', error);
        showMessage('collateral-message', `Error: ${handleTransactionError(error)}`, 'error');
        throw error;
      }
    }

    // Event listeners
    // Connect/disconnect wallet
    elements.connectWallet.addEventListener('click', async () => {
      if (state.isConnected) {
        disconnectWallet();
      } else {
        await connectWallet();
      }
    });

    // Refresh balances
    elements.refreshBalances.addEventListener('click', async () => {
      await updateBalances();
    });

    // Auto refresh toggle
    elements.autoRefreshToggle.addEventListener('click', () => {
      if (state.isAutoRefreshing) {
        stopAutoRefresh();
      } else {
        startAutoRefresh();
      }
    });

    // Approve tokens
    elements.approveCurrency.addEventListener('click', async () => {
      await approveToken('currency');
    });

    elements.approveCompany.addEventListener('click', async () => {
      await approveToken('company');
    });
    
    // Swap tokens
    elements.executeSwap.addEventListener('click', async () => {
      const amount = elements.swapAmount.value;
      // Check if YES is selected (if NO is checked, then YES is not selected)
      const isYesToken = !elements.noToggle.checked;
      // Check if Buy is selected (if Sell is checked, then Buy is not selected)
      const isBuy = !elements.sellToggle.checked;
      
      console.log("Swap execution:", { 
        action: isBuy ? "Buy" : "Sell", 
        tokenType: isYesToken ? "YES" : "NO", 
        amount 
      });
      
      // Always use 'company' tokens for the swap
      await executeSwap('company', isBuy, amount, isYesToken);
    });

    // Split and merge collateral
    elements.currencySplit.addEventListener('click', async () => {
      const amount = elements.currencySplitAmount.value;
      await addCollateral('currency', amount);
    });
    
    elements.currencyMerge.addEventListener('click', async () => {
      const amount = elements.currencySplitAmount.value;
      await removeCollateral('currency', amount);
    });
    
    elements.companySplit.addEventListener('click', async () => {
      const amount = elements.companySplitAmount.value;
      await addCollateral('company', amount);
    });
    
    elements.companyMerge.addEventListener('click', async () => {
      const amount = elements.companySplitAmount.value;
      await removeCollateral('company', amount);
    });

    // Initialize the app
    document.addEventListener('DOMContentLoaded', async function() {
      console.log('üîÑ DOMContentLoaded event fired');
      
      // Initialize debug information
      initializeDebugInfo();
      
      // Check if debug mode is enabled
      const urlParams = new URLSearchParams(window.location.search);
      if (urlParams.has('debug')) {
        const debugButtonContainer = document.getElementById('debug-button-container');
        if (debugButtonContainer) {
          debugButtonContainer.style.display = 'block';
          
          // Add click event listener to the debug button
          const debugButton = document.getElementById('debug-button');
          if (debugButton) {
            debugButton.addEventListener('click', function() {
              console.log('Debug button clicked, running debug function...');
             // debugSwapBalance();
            });
          }
        }
      }
      
      // Check if MetaMask is installed
      if (window.ethereum) {
        try {
          // Check if already connected
          const accounts = await window.ethereum.request({ method: 'eth_accounts' });
          if (accounts.length > 0) {
            // User is already connected
            await connectWallet();
          }
        } catch (error) {
          console.error('Error checking connection:', error);
        }
      } else {
        showMessage('connection-message', 'MetaMask is not installed', 'error');
      }
      
      try {
        // Set up event listeners for the swap section
        setupSwapEventListeners();
      } catch (error) {
        console.error('Error setting up swap event listeners:', error);
      }
      
      // Update the swap balance display
      console.log('üîÑ DOMContentLoaded event, updating swap balance display');
      try {
        updateAvailableBalanceForSwap();
      } catch (error) {
        console.error('Error updating available balance for swap:', error);
      }
      
      // Fetch initial prices
      console.log('üîÑ Fetching initial market prices');
      try {
        fetchPoolPrices();
      } catch (error) {
        console.error('Error fetching initial market prices:', error);
        showMessage('price-message', `Error fetching prices: ${error.message}`, 'error');
      }
    });
    
    // Function to set up event listeners for the swap section
    function setupSwapEventListeners() {
      console.log('Setting up swap event listeners...');
      
      // Connect wallet button
      if (elements.connectWallet) {
        elements.connectWallet.addEventListener('click', connectWallet);
      }
      
      // Approve buttons
      if (elements.approveCurrency) {
        elements.approveCurrency.addEventListener('click', () => approveToken('currency'));
      }
      if (elements.approveCompany) {
        elements.approveCompany.addEventListener('click', () => approveToken('company'));
      }
      
      // Swap button
      if (elements.executeSwap) {
        const swapButton = elements.executeSwap;
        
        // Clone the button to remove any existing listeners
        const newSwapButton = swapButton.cloneNode(true);
        swapButton.parentNode.replaceChild(newSwapButton, swapButton);
        elements.executeSwap = newSwapButton;
        
        // Add new click event listener
        newSwapButton.addEventListener('click', function(event) {
          event.preventDefault();
          
          // Define getSelectedTokenType function inline if it doesn't exist
          const getSelectedTokenType = function() {
            // For this application, the token type is determined by the action:
            // When selling, we're selling company tokens
            // When buying, we're using currency tokens
            
            const sellRadio = document.getElementById('sell-toggle');
            
            // If sell is selected, then we're dealing with company tokens
            if (sellRadio && sellRadio.checked) {
              console.log('Sell mode detected - using company token type');
              return 'company';
            }
            
            // Default to currency for buy mode
            console.log('Buy mode detected - using currency token type');
            return 'currency';
          };
          
          // Get values from UI
          const tokenType = getSelectedTokenType();
          
          // Define getSelectedActionType function inline if it doesn't exist
          const getSelectedActionType = function() {
            const buyRadio = document.getElementById('buy-toggle'); // Fixed ID from buy-action-type to buy-toggle
            const sellRadio = document.getElementById('sell-toggle'); // Fixed ID from sell-action-type to sell-toggle
            
            if (buyRadio && buyRadio.checked) {
              return 'buy';
            } else if (sellRadio && sellRadio.checked) {
              return 'sell';
            }
            
            // Default to buy if no selection is found
            console.warn('No action type selected, defaulting to buy');
            return 'buy';
          };
          
          const actionType = getSelectedActionType();
          const amount = elements.swapAmount ? elements.swapAmount.value : '0';
          const isYesToken = elements.yesToggle && elements.yesToggle.checked;
          
          // Determine if this is a buy or sell
          const isBuy = actionType === 'buy';
          
          // Log the swap execution details
          console.log('Swap button clicked, executing swap with:', {
            tokenType,
            isBuy,
            amount,
            isYesToken
          });
          
          // Execute the swap
          executeSwap(tokenType, isBuy, amount, isYesToken);
        });
      }
      
      // MAX button
      const maxButton = document.getElementById('max-button');
      if (maxButton) {
        maxButton.addEventListener('click', handleSetMax);
      } else {
        console.warn('MAX button not found');
      }
      
      // Token type radio buttons
      const currencyToggle = document.getElementById('currency-toggle');
      const companyToggle = document.getElementById('company-toggle');
      if (currencyToggle) {
        currencyToggle.addEventListener('change', updateAvailableBalanceForSwap);
      }
      if (companyToggle) {
        companyToggle.addEventListener('change', updateAvailableBalanceForSwap);
      }
      
      // Action type radio buttons
      if (elements.buyToggle) {
        elements.buyToggle.addEventListener('change', updateAvailableBalanceForSwap);
      }
      if (elements.sellToggle) {
        elements.sellToggle.addEventListener('change', updateAvailableBalanceForSwap);
      }
      
      // Yes/No radio buttons
      if (elements.yesToggle) {
        elements.yesToggle.addEventListener('change', updateAvailableBalanceForSwap);
      }
      if (elements.noToggle) {
        elements.noToggle.addEventListener('change', updateAvailableBalanceForSwap);
      }
      
      // Refresh prices button
      if (elements.refreshPrices) {
        elements.refreshPrices.addEventListener('click', fetchPoolPrices);
      }
      
      // Debug prices button
      const debugPricesButton = document.getElementById('debug-prices');
      if (debugPricesButton) {
        debugPricesButton.addEventListener('click', async function() {
          console.log('üîç Debug Prices button clicked');
          
          try {
            // Show a message that we're starting debug
            showMessage('price-message', 'Starting price debug process...', 'info');
            
            // Check if ethers.js is loaded
            console.log('üîç Checking if ethers.js is loaded:', typeof ethers !== 'undefined' ? 'YES' : 'NO');
            
            // Check contract addresses
            console.log('üîç Contract addresses:', {
              YES_POOL: POOL_CONFIG_YES.address,
              NO_POOL: POOL_CONFIG_NO.address,
              SDAI_RATE_PROVIDER: CONTRACT_ADDRESSES.sdaiRateProvider,
              WXDAI: CONTRACT_ADDRESSES.wxdai,
              YES_SDAI: CONTRACT_ADDRESSES.yes_sdai,
              NO_SDAI: CONTRACT_ADDRESSES.no_sdai
            });
            
            // Test RPC connection
            console.log('üîç Testing RPC connection...');
            try {
              const provider = new ethers.providers.JsonRpcProvider("https://rpc.ankr.com/gnosis");
              const blockNumber = await provider.getBlockNumber();
              console.log('‚úÖ RPC connection successful! Current block number:', blockNumber);
            } catch (error) {
              console.error('‚ùå RPC connection failed:', error);
              showMessage('price-message', `RPC connection failed: ${error.message}`, 'error');
              return;
            }
            
            // Test SDAI rate provider contract
            console.log('üîç Testing SDAI rate provider contract...');
            try {
              const provider = new ethers.providers.JsonRpcProvider("https://rpc.ankr.com/gnosis");
              const sdaiRateProviderAbi = ["function getRate() external view returns (uint256)"];
              const sdaiRateProviderContract = new ethers.Contract(
                CONTRACT_ADDRESSES.sdaiRateProvider,
                sdaiRateProviderAbi,
                provider
              );
              const sdaiRate = await sdaiRateProviderContract.getRate();
              console.log('‚úÖ SDAI rate provider contract working! Rate:', sdaiRate.toString());
            } catch (error) {
              console.error('‚ùå SDAI rate provider contract failed:', error);
              showMessage('price-message', `SDAI rate provider failed: ${error.message}`, 'error');
              return;
            }
            
            // Test YES pool contract
            console.log('üîç Testing YES pool contract...');
            try {
              const provider = new ethers.providers.JsonRpcProvider("https://rpc.ankr.com/gnosis");
              const yesPoolContract = new ethers.Contract(
                POOL_CONFIG_YES.address,
                UNISWAP_V3_POOL_ABI,
                provider
              );
              const yesSlot0 = await yesPoolContract.slot0();
              console.log('‚úÖ YES pool contract working! sqrtPriceX96:', yesSlot0.sqrtPriceX96.toString());
            } catch (error) {
              console.error('‚ùå YES pool contract failed:', error);
              showMessage('price-message', `YES pool contract failed: ${error.message}`, 'error');
              return;
            }
            
            // If all tests pass, try fetching prices
            console.log('üîç All tests passed! Attempting to fetch prices...');
            showMessage('price-message', 'All tests passed! Fetching prices...', 'info');
            
            // Call the fetchPoolPrices function
            await fetchPoolPrices();
            
          } catch (error) {
            console.error('‚ùå Debug process failed:', error);
            showMessage('price-message', `Debug process failed: ${error.message}`, 'error');
          }
        });
      }
      
      // Collateral buttons
      if (elements.currencySplit) {
        elements.currencySplit.addEventListener('click', () => handleAddCollateral('currency'));
      }
      if (elements.currencyMerge) {
        elements.currencyMerge.addEventListener('click', () => handleRemoveCollateral('currency'));
      }
      if (elements.companySplit) {
        elements.companySplit.addEventListener('click', () => handleAddCollateral('company'));
      }
      if (elements.companyMerge) {
        elements.companyMerge.addEventListener('click', () => handleRemoveCollateral('company'));
      }
    }

    // Cleanup function to run when page unloads
    window.addEventListener('beforeunload', () => {
      // Clear any intervals
      if (state.refreshInterval) {
        clearInterval(state.refreshInterval);
      }
      
      // Remove event listeners
      removeEventListeners();
    });

    /**
     * Handle MAX button click - sets the maximum amount based on the available balance
     */
    function handleSetMax() {
      console.log('MAX button clicked - setting maximum amount');
      
      // Check if the swap amount input exists
      if (!elements.swapAmount) {
        console.warn('Swap amount input not found');
        return;
      }
      
      // Get the available balance from the UI
      const availableBalanceElement = document.getElementById('available-balance-amount');
      if (!availableBalanceElement) {
        console.warn('Available balance element not found');
        return;
      }
      
      // Get the available balance value
      const availableBalance = availableBalanceElement.textContent;
      if (!availableBalance || isNaN(parseFloat(availableBalance))) {
        console.warn('Invalid available balance:', availableBalance);
        return;
      }
      
      // Set the input value to the available balance
      elements.swapAmount.value = availableBalance;
      
      console.log('Set maximum amount to available balance:', availableBalance);
    }

    // Function to update the available balance for swaps based on selected token type and action type
    async function updateAvailableBalanceForSwap() {
      console.log('üîç updateAvailableBalanceForSwap CALLED');
      
      // Check if connected and balances are available
      if (!state.isConnected || !state.balances) {
        console.log('‚ö†Ô∏è Not connected or no balances available', { isConnected: state.isConnected, hasBalances: !!state.balances });
        const availableBalanceElement = document.getElementById('available-balance-amount');
        const walletBalanceElement = document.getElementById('wallet-balance-for-swap');
        const positionBalanceElement = document.getElementById('position-balance-for-swap');
        
        if (availableBalanceElement) availableBalanceElement.textContent = '0';
        if (walletBalanceElement) walletBalanceElement.textContent = '0';
        if (positionBalanceElement) positionBalanceElement.textContent = '0';
        return;
      }
      
      // Get the selected token type and action type
      const tokenTypeElement = document.querySelector('input[name="token-type"]:checked');
      const actionTypeElement = document.querySelector('input[name="action-type"]:checked');
      
      console.log('üîç Radio button elements:', { tokenTypeElement, actionTypeElement });
      
      if (!tokenTypeElement || !actionTypeElement) {
        console.log('‚ö†Ô∏è Radio buttons not found');
        return;
      }
      
      const tokenType = tokenTypeElement.value; // 'yes' or 'no'
      const actionType = actionTypeElement.value; // 'buy' or 'sell'
      
      // Determine which token is the base token based on the action
      // For buy: we're using currency to buy YES/NO tokens
      // For sell: we're selling YES/NO tokens to get currency
      const baseTokenType = actionType === 'buy' ? 'currency' : 'company';
      
      console.log('üîç Selected values:', { tokenType, actionType, baseTokenType });
      
      let walletBalance = 0;
      let positionBalance = 0;
      let totalAvailable = 0;
      
      if (actionType === 'buy') {
        // When buying YES/NO tokens, we use currency from wallet and position
        // Use the exact string values without parsing to float to maintain precision
        walletBalance = state.balances.currency.wallet.formatted;
        positionBalance = state.balances.currency.collateral[tokenType];
      } else {
        // When selling YES/NO tokens, we use the company wallet balance and position
        walletBalance = state.balances.company.wallet.formatted;
        positionBalance = state.balances.company.collateral[tokenType];
      }
      
      // Calculate total available using BigNumber for precision
      const walletBN = ethers.utils.parseEther(walletBalance);
      const positionBN = ethers.utils.parseEther(positionBalance);
      const totalBN = walletBN.add(positionBN);
      totalAvailable = ethers.utils.formatEther(totalBN);
      
      // Update the UI with the exact string values to maintain full precision
      const availableBalanceElement = document.getElementById('available-balance-amount');
      const walletBalanceElement = document.getElementById('wallet-balance-for-swap');
      const positionBalanceElement = document.getElementById('position-balance-for-swap');
      
      if (availableBalanceElement) availableBalanceElement.textContent = totalAvailable;
      if (walletBalanceElement) walletBalanceElement.textContent = walletBalance;
      if (positionBalanceElement) positionBalanceElement.textContent = positionBalance;
      
      // Add a note about collateral if needed
      const swapMessage = document.getElementById('swap-message');
      if (swapMessage) {
        if (actionType === 'buy') {
          // Use BigNumber for precise comparison
          const walletBN = ethers.utils.parseEther(walletBalance);
          const positionBN = ethers.utils.parseEther(positionBalance);
          const totalBN = ethers.utils.parseEther(totalAvailable);
          
          if (positionBN.lt(totalBN)) {
            // Calculate collateral needed using BigNumber
            const collateralNeededBN = totalBN.sub(positionBN);
            const collateralNeeded = ethers.utils.formatEther(collateralNeededBN);
            swapMessage.textContent = `Note: Using the MAX amount will require adding ${collateralNeeded} ${TOKEN_CONFIG.currency.symbol} as collateral.`;
          } else {
            swapMessage.textContent = '';
          }
        } else {
          // Clear any previous message for sell operations
          swapMessage.textContent = '';
        }
      }
      
      console.log('üîç Available balance update:', { 
        action: actionType, 
        tokenType, 
        walletBalance, 
        positionBalance, 
        totalAvailable,
        baseTokenType
      });
    }

    // Function to update swap steps status
    function updateSwapStep(step, status, message = '') {
      const stepElement = document.getElementById(`step${step}-status`);
      if (stepElement) {
        stepElement.textContent = status;
        
        // Update color based on status
        if (status === 'Complete') {
          stepElement.style.color = '#4CAF50';
        } else if (status === 'In Progress') {
          stepElement.style.color = '#2196F3';
        } else if (status === 'Error') {
          stepElement.style.color = '#F44336';
        } else {
          stepElement.style.color = '#757575';
        }
      }
      
      if (message) {
        document.getElementById('swap-message').textContent = message;
      }
    }

    // Function to reset all swap steps
    function resetSwapSteps() {
      for (let i = 1; i <= 3; i++) {
        updateSwapStep(i, 'Waiting');
      }
      document.getElementById('swap-message').textContent = '';
    }

    // Debug function to test all combinations of token type and action type
    function debugSwapBalance() {
      console.log('üêû DEBUGGING SWAP BALANCE üêû');
      console.log('‚ö†Ô∏è MANUAL TEST STARTING ‚ö†Ô∏è');
      
      // Check if all necessary elements exist
      const elements = {
        yesToggle: document.getElementById('yes-toggle'),
        noToggle: document.getElementById('no-toggle'),
        buyToggle: document.getElementById('buy-toggle'),
        sellToggle: document.getElementById('sell-toggle')
        // Removed currencyToggle and companyToggle as they no longer exist
      };
      
      // Check if any elements are missing
      const missingElements = Object.entries(elements)
        .filter(([key, element]) => !element)
        .map(([key]) => key);
      
      if (missingElements.length > 0) {
        console.warn('‚ö†Ô∏è Missing elements:', missingElements.join(', '));
        console.warn('‚ö†Ô∏è Aborting test due to missing elements');
        return;
      }
      
      // Save original selections to restore later
      const originalSelections = {
        tokenType: document.querySelector('input[name="token-type"]:checked')?.value,
        actionType: document.querySelector('input[name="action-type"]:checked')?.value
      };
      
      console.log('Original selections:', originalSelections);
      
      // Log current state
      console.log('Current state:', {
        isConnected: state.isConnected,
        hasBalances: !!state.balances,
        balances: JSON.stringify(state.balances, null, 2)
      });
      
      // Define test cases with expected values for buy operations that include both wallet and position balances
      const testCases = [
        { 
          token: 'yes', 
          base: 'currency', 
          action: 'buy', 
          // For buy operations, we expect the total to be wallet + position
          expectedTotal: (() => {
            const walletBN = ethers.utils.parseEther(state.balances.currency.wallet.formatted);
            const positionBN = ethers.utils.parseEther(state.balances.currency.collateral.yes);
            return ethers.utils.formatEther(walletBN.add(positionBN));
          })()
        },
        { token: 'yes', base: 'currency', action: 'sell', expectedTotal: state.balances.company.collateral.yes },
        { 
          token: 'no', 
          base: 'currency', 
          action: 'buy', 
          // For buy operations, we expect the total to be wallet + position
          expectedTotal: (() => {
            const walletBN = ethers.utils.parseEther(state.balances.currency.wallet.formatted);
            const positionBN = ethers.utils.parseEther(state.balances.currency.collateral.no);
            return ethers.utils.formatEther(walletBN.add(positionBN));
          })()
        },
        { token: 'no', base: 'currency', action: 'sell', expectedTotal: state.balances.company.collateral.no },
        { 
          token: 'yes', 
          base: 'company', 
          action: 'buy', 
          // For buy operations, we expect the total to be wallet + position
          expectedTotal: (() => {
            const walletBN = ethers.utils.parseEther(state.balances.currency.wallet.formatted);
            const positionBN = ethers.utils.parseEther(state.balances.currency.collateral.yes);
            return ethers.utils.formatEther(walletBN.add(positionBN));
          })()
        },
        { token: 'yes', base: 'company', action: 'sell', expectedTotal: state.balances.company.collateral.yes },
        { 
          token: 'no', 
          base: 'company', 
          action: 'buy', 
          // For buy operations, we expect the total to be wallet + position
          expectedTotal: (() => {
            const walletBN = ethers.utils.parseEther(state.balances.currency.wallet.formatted);
            const positionBN = ethers.utils.parseEther(state.balances.currency.collateral.no);
            return ethers.utils.formatEther(walletBN.add(positionBN));
          })()
        },
        { token: 'no', base: 'company', action: 'sell', expectedTotal: state.balances.company.collateral.no }
      ];
      
      console.log('Running test cases...');
      
      // Save original UI state
      const originalWalletBalance = document.getElementById('wallet-balance-for-swap').textContent;
      const originalPositionBalance = document.getElementById('position-balance-for-swap').textContent;
      const originalTotalBalance = document.getElementById('available-balance-amount').textContent;
      const originalSwapMessage = document.getElementById('swap-message').textContent;
      
      // Run each test case
      testCases.forEach(testCase => {
        console.log('===================================');
        console.log(`Test Case: token=${testCase.token}, base=${testCase.base}, action=${testCase.action}`);
        
        try {
          // Set the radio buttons programmatically without triggering change events
          const tokenToggle = document.getElementById(`${testCase.token}-toggle`);
          const actionToggle = document.getElementById(`${testCase.action}-toggle`);
          
          if (tokenToggle && actionToggle) {
            // Temporarily remove event listeners by cloning and replacing
            const tokenToggleClone = tokenToggle.cloneNode(true);
            const actionToggleClone = actionToggle.cloneNode(true);
            
            // Set checked state
            tokenToggleClone.checked = true;
            actionToggleClone.checked = true;
            
            // Replace elements (this removes event listeners)
            tokenToggle.parentNode.replaceChild(tokenToggleClone, tokenToggle);
            actionToggle.parentNode.replaceChild(actionToggleClone, actionToggle);
            
            // Call the function directly
            console.log('Calling updateAvailableBalanceForSwap...');
            updateAvailableBalanceForSwap();
            
            // Get the results
            const walletDisplay = document.getElementById('wallet-balance-for-swap').textContent;
            const positionDisplay = document.getElementById('position-balance-for-swap').textContent;
            const totalDisplay = document.getElementById('available-balance-amount').textContent;
            
            // Check if the result matches the expected value - compare the exact string values
            // Convert both to BigNumber to ensure we're comparing the same numeric value
            // regardless of string formatting differences
            const displayBN = ethers.utils.parseEther(totalDisplay);
            const expectedBN = ethers.utils.parseEther(testCase.expectedTotal);
            const matches = displayBN.eq(expectedBN);
            
            console.log('Result:', {
              walletDisplay,
              positionDisplay,
              totalDisplay,
              expectedTotal: testCase.expectedTotal,
              matches
            });
          } else {
            console.error('Could not find toggle elements for test case:', testCase);
          }
        } catch (error) {
          console.error('Error in test case:', error);
        }
      });
      
      // Restore original selections by recreating the event listeners
      console.log('Restoring original selections:', originalSelections);
      
      // Re-setup all event listeners to ensure they work properly
      setupSwapEventListeners();
      
      // Now set the original selections
      if (originalSelections.tokenType) {
        document.getElementById(`${originalSelections.tokenType}-toggle`).checked = true;
      }
      if (originalSelections.actionType) {
        document.getElementById(`${originalSelections.actionType}-toggle`).checked = true;
      }
      
      // Restore original UI state
      document.getElementById('wallet-balance-for-swap').textContent = originalWalletBalance;
      document.getElementById('position-balance-for-swap').textContent = originalPositionBalance;
      document.getElementById('available-balance-amount').textContent = originalTotalBalance;
      document.getElementById('swap-message').textContent = originalSwapMessage;
      
      // Call updateAvailableBalanceForSwap to ensure UI is updated correctly
      updateAvailableBalanceForSwap();
      
      console.log('üêû DEBUG COMPLETE üêû');
      console.log('Original selections restored:', {
        tokenType: document.querySelector('input[name="token-type"]:checked')?.value,
        actionType: document.querySelector('input[name="action-type"]:checked')?.value
      });
    }
    
    // Call the debug function after a delay to ensure everything is loaded
    setTimeout(function() {
      // Only run the debug function if the URL contains the debug parameter
      const urlParams = new URLSearchParams(window.location.search);
      if (urlParams.has('debug')) {
        console.log("üïí Timeout expired, running debug function...");
        debugSwapBalance();
      }
    }, 5000); // Run after 5 seconds

    // Constants for contracts
    const WXDAI_ADDRESS = "0xe91D153E0b41518A2Ce8Dd3D7944Fa863463a97d";
    const SDAI_CONTRACT_RATE = "0xaf204776c7245bF4147c2612BF6e5972Ee483701";
    const SDAI_RATE_PROVIDER_ABI = [
      "function getRate() external view returns (uint256)"
    ];
    
    // We're using the UNISWAP_V3_POOL_ABI already defined above
    
    // SushiSwap V2 Factory ABI
    const SUSHISWAP_V2_FACTORY_ABI = [
      "function getPair(address tokenA, address tokenB) external view returns (address pair)"
    ];
    
    // SushiSwap V2 Pair ABI
    const SUSHISWAP_V2_PAIR_ABI = [
      "function token0() external view returns (address)",
      "function token1() external view returns (address)",
      "function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast)"
    ];
    
    // SushiSwap V2 Factory address
    const SUSHISWAP_V2_FACTORY = "0xc35dadb65012ec5796536bd9864ed8773abc74c4"; // SushiSwap factory on Gnosis Chain (fixed checksum)
    
    // Pool configurations
    const POOL_CONFIG_YES = {
      address: "0x9a14d28909f42823ee29847f87a15fb3b6e8aed3", // YES pool address (corrected from contracts.js)
      tokenCompanySlot: 0 // Which token slot the company token is in (0 or 1) - corrected from contracts.js
    };
    
    const POOL_CONFIG_NO = {
      address: "0x6E33153115Ab58dab0e0F1E3a2ccda6e67FA5cD7", // NO pool address (corrected from contracts.js)
      tokenCompanySlot: 1 // Which token slot the company token is in (0 or 1)
    };
    
    // Currency positions configuration
    const CURRENCY_POSITIONS = {
      yes: {
        wrap: {
          wrappedCollateralTokenAddress: "0x493A0D1c776f8797297Aa8B34594fBd0A7F8968a" // YES_SDAI - correct address from contracts.js
        }
      },
      no: {
        wrap: {
          wrappedCollateralTokenAddress: "0xE1133Ef862f3441880adADC2096AB67c63f6E102" // NO_SDAI - correct address from contracts.js
        }
      }
    };
    
    // Company positions configuration
    const COMPANY_POSITIONS = {
      yes: {
        wrap: {
          wrappedCollateralTokenAddress: "0x177304d505eCA60E1aE0dAF1bba4A4c4181dB8Ad" // YES_GNO - correct address from contracts.js
        }
      },
      no: {
        wrap: {
          wrappedCollateralTokenAddress: "0xf1B3E5Ffc0219A4F8C0ac69EC98C97709EdfB6c9" // NO_GNO - correct address from contracts.js
        }
      }
    };
    
    /**
     * Calculate price from sqrtPriceX96 value
     * @param {BigNumber} sqrtPriceX96 - The square root price in Q96 format from Uniswap V3 Pool
     * @param {Number} tokenCompanySlot - The token slot (0 or 1) to determine if price needs to be inverted
     * @returns {Number} The calculated price
     */
    function calculatePriceFromSqrtPriceX96(sqrtPriceX96, tokenCompanySlot) {
      // Convert sqrtPriceX96 to ethers BigNumber if it's not already
      const sqrtPriceX96BN = ethers.BigNumber.isBigNumber(sqrtPriceX96) 
        ? sqrtPriceX96 
        : ethers.BigNumber.from(sqrtPriceX96);
      
      // For simplicity, we'll convert to a decimal string and use JavaScript math
      const sqrtPriceStr = ethers.utils.formatUnits(sqrtPriceX96BN, 0);
      const sqrtPrice = parseFloat(sqrtPriceStr);
      const price = (sqrtPrice * sqrtPrice) / 2**192;
      
      // If tokenCompanySlot is 1, we need to invert the price
      return tokenCompanySlot === 1 ? 1 / price : price;
    }
    
    /**
     * Fetch the SDAI to USD rate from the rate provider contract
     * This uses the getRate function and converts the result to a decimal by dividing by 10^18
     */
    async function fetchSdaiPrice() {
      try {
        console.log('üîÑ fetchSdaiPrice: Starting to fetch SDAI price...');
        console.log('üìä Debug: SDAI Rate Provider address:', CONTRACT_ADDRESSES.sdaiRateProvider);
        
        // Create provider
        console.log('üîÑ fetchSdaiPrice: Creating provider...');
        const provider = new ethers.providers.JsonRpcProvider("https://rpc.ankr.com/gnosis");
        console.log('‚úÖ fetchSdaiPrice: Provider created successfully');
        
        // Create contract instance for SDAI rate provider
        console.log('üîÑ fetchSdaiPrice: Creating SDAI rate provider contract...');
        const sdaiRateProviderAbi = [
          "function getRate() external view returns (uint256)"
        ];
        
        const sdaiRateProviderContract = new ethers.Contract(
          getChecksumAddress(CONTRACT_ADDRESSES.sdaiRateProvider),
          sdaiRateProviderAbi,
          provider
        );
        console.log('‚úÖ fetchSdaiPrice: SDAI rate provider contract created successfully');
        
        // Fetch SDAI rate
        console.log('üîÑ fetchSdaiPrice: Fetching SDAI rate...');
        const sdaiRate = await sdaiRateProviderContract.getRate();
        console.log('‚úÖ fetchSdaiPrice: SDAI rate fetched:', sdaiRate.toString());
        
        // Convert to decimal - FIXED: Changed from 27 to 18 decimals to match useFutarchy.js
        const sdaiPrice = parseFloat(ethers.utils.formatUnits(sdaiRate, 18));
        console.log('‚úÖ fetchSdaiPrice: SDAI price calculated:', sdaiPrice);
        
        return sdaiPrice;
      } catch (error) {
        console.error('‚ùå fetchSdaiPrice: Error fetching SDAI price:', error);
        console.error('‚ùå fetchSdaiPrice: Detailed error information:', {
          message: error.message,
          code: error.code,
          stack: error.stack
        });
        throw error;
      }
    }
    
    /**
     * Fetch currency token prices in terms of XDAI from SushiSwap V2
     * This will get the YES_SDAI and NO_SDAI prices in XDAI
     */
    async function fetchCurrencyPricesInXdai() {
      try {
        console.log('üîÑ fetchCurrencyPricesInXdai: Starting to fetch currency prices...');
        console.log('üìä Debug: Contract addresses being used:', {
          YES_SDAI: CONTRACT_ADDRESSES.yes_sdai,
          NO_SDAI: CONTRACT_ADDRESSES.no_sdai,
          WXDAI: CONTRACT_ADDRESSES.wxdai
        });
        
        // Create provider
        console.log('üîÑ fetchCurrencyPricesInXdai: Creating provider...');
        const provider = new ethers.providers.JsonRpcProvider("https://rpc.ankr.com/gnosis");
        console.log('‚úÖ fetchCurrencyPricesInXdai: Provider created successfully');
        
        // Create SushiSwap factory contract
        console.log('üîÑ fetchCurrencyPricesInXdai: Creating SushiSwap factory contract...');
        const factory = new ethers.Contract(
          getChecksumAddress(SUSHISWAP_V2_FACTORY),
          SUSHISWAP_V2_FACTORY_ABI,
          provider
        );
        console.log('‚úÖ fetchCurrencyPricesInXdai: SushiSwap factory contract created successfully');
        
        // Get YES token pair (YES_SDAI to WXDAI)
        console.log('üîÑ fetchCurrencyPricesInXdai: Getting YES token pair...');
        const yesPairAddress = await factory.getPair(
          getChecksumAddress(CONTRACT_ADDRESSES.wxdai),
          getChecksumAddress(CONTRACT_ADDRESSES.yes_sdai)
        );
        console.log('‚úÖ fetchCurrencyPricesInXdai: YES token pair address:', yesPairAddress);
        
        // Get NO token pair (NO_SDAI to WXDAI)
        console.log('üîÑ fetchCurrencyPricesInXdai: Getting NO token pair...');
        const noPairAddress = await factory.getPair(
          getChecksumAddress(CONTRACT_ADDRESSES.wxdai),
          getChecksumAddress(CONTRACT_ADDRESSES.no_sdai)
        );
        console.log('‚úÖ fetchCurrencyPricesInXdai: NO token pair address:', noPairAddress);
        
        let yesCurrencyInXdai = null;
        let noCurrencyInXdai = null;
        
        // Calculate YES_SDAI price in XDAI if pair exists
        if (yesPairAddress !== "0x0000000000000000000000000000000000000000") {
          console.log('üîÑ fetchCurrencyPricesInXdai: Creating YES pair contract...');
          const yesPair = new ethers.Contract(getChecksumAddress(yesPairAddress), SUSHISWAP_V2_PAIR_ABI, provider);
          console.log('‚úÖ fetchCurrencyPricesInXdai: YES pair contract created successfully');
          
          console.log('üîÑ fetchCurrencyPricesInXdai: Getting YES token0...');
          const yesToken0 = await yesPair.token0();
          console.log('‚úÖ fetchCurrencyPricesInXdai: YES token0:', yesToken0);
          
          console.log('üîÑ fetchCurrencyPricesInXdai: Getting YES reserves...');
          const [yesReserve0, yesReserve1] = await yesPair.getReserves();
          console.log('‚úÖ fetchCurrencyPricesInXdai: YES reserves:', {
            reserve0: yesReserve0.toString(),
            reserve1: yesReserve1.toString()
          });
          
          // Calculate price based on which token is token0
          const yesTokenAddress = getChecksumAddress(CONTRACT_ADDRESSES.yes_sdai);
          
          // Invert the calculation to get YES_SDAI per XDAI instead of XDAI per YES_SDAI
          yesCurrencyInXdai = yesTokenAddress.toLowerCase() === yesToken0.toLowerCase()
            ? ethers.utils.formatEther(yesReserve0) / ethers.utils.formatEther(yesReserve1)
            : ethers.utils.formatEther(yesReserve1) / ethers.utils.formatEther(yesReserve0);
            
          console.log('‚úÖ fetchCurrencyPricesInXdai: YES_SDAI per XDAI:', yesCurrencyInXdai);
        }
        
        // Calculate NO_SDAI price in XDAI if pair exists
        if (noPairAddress !== "0x0000000000000000000000000000000000000000") {
          console.log('üîÑ fetchCurrencyPricesInXdai: Creating NO pair contract...');
          const noPair = new ethers.Contract(getChecksumAddress(noPairAddress), SUSHISWAP_V2_PAIR_ABI, provider);
          console.log('‚úÖ fetchCurrencyPricesInXdai: NO pair contract created successfully');
          
          console.log('üîÑ fetchCurrencyPricesInXdai: Getting NO token0...');
          const noToken0 = await noPair.token0();
          console.log('‚úÖ fetchCurrencyPricesInXdai: NO token0:', noToken0);
          
          console.log('üîÑ fetchCurrencyPricesInXdai: Getting NO reserves...');
          const [noReserve0, noReserve1] = await noPair.getReserves();
          console.log('‚úÖ fetchCurrencyPricesInXdai: NO reserves:', {
            reserve0: noReserve0.toString(),
            reserve1: noReserve1.toString()
          });
          
          // Calculate price based on which token is token0
          const noTokenAddress = getChecksumAddress(CONTRACT_ADDRESSES.no_sdai);
          
          // Invert the calculation to get NO_SDAI per XDAI instead of XDAI per NO_SDAI
          noCurrencyInXdai = noTokenAddress.toLowerCase() === noToken0.toLowerCase()
            ? ethers.utils.formatEther(noReserve0) / ethers.utils.formatEther(noReserve1)
            : ethers.utils.formatEther(noReserve1) / ethers.utils.formatEther(noReserve0);
            
          console.log('‚úÖ fetchCurrencyPricesInXdai: NO_SDAI per XDAI:', noCurrencyInXdai);
        }
        
        return { yesCurrencyInXdai, noCurrencyInXdai };
      } catch (error) {
        console.error('‚ùå fetchCurrencyPricesInXdai: Error fetching currency prices:', error);
        console.error('‚ùå fetchCurrencyPricesInXdai: Detailed error information:', {
          message: error.message,
          code: error.code,
          stack: error.stack
        });
        throw error;
      }
    }
    
    /**
     * Initialize the debug information with contract addresses and ABIs
     */
    function initializeDebugInfo() {
      // Set contract addresses
      document.getElementById('debug-yes-pool-address').textContent = POOL_CONFIG_YES.address;
      document.getElementById('debug-no-pool-address').textContent = POOL_CONFIG_NO.address;
      document.getElementById('debug-sdai-rate-address').textContent = CONTRACT_ADDRESSES.sdaiRateProvider;
      document.getElementById('debug-wxdai-address').textContent = CONTRACT_ADDRESSES.wxdai;
      document.getElementById('debug-yes-sdai-address').textContent = CONTRACT_ADDRESSES.yes_sdai;
      document.getElementById('debug-no-sdai-address').textContent = CONTRACT_ADDRESSES.no_sdai;
      document.getElementById('debug-yes-gno-address').textContent = CONTRACT_ADDRESSES.yes_gno;
      document.getElementById('debug-no-gno-address').textContent = CONTRACT_ADDRESSES.no_gno;
      
      console.log('‚úÖ Debug information initialized with addresses:', {
        YES_POOL: POOL_CONFIG_YES.address,
        NO_POOL: POOL_CONFIG_NO.address,
        SDAI_RATE_PROVIDER: CONTRACT_ADDRESSES.sdaiRateProvider,
        WXDAI: CONTRACT_ADDRESSES.wxdai,
        YES_SDAI: CONTRACT_ADDRESSES.yes_sdai,
        NO_SDAI: CONTRACT_ADDRESSES.no_sdai,
        YES_GNO: CONTRACT_ADDRESSES.yes_gno,
        NO_GNO: CONTRACT_ADDRESSES.no_gno
      });
    }

    /**
     * Update the debug raw data with the latest fetched information
     */
    function updateDebugRawData(data) {
      const debugRawData = document.getElementById('debug-raw-data');
      if (debugRawData) {
        // Format the data as JSON with indentation
        debugRawData.innerHTML = `<pre>${JSON.stringify(data, null, 2)}</pre>`;
      }
    }

    /**
     * Fetch the latest pool prices directly from Uniswap V3 pool contracts
     * This uses the slot0 function to get the sqrtPriceX96 value
     */
    async function fetchPoolPrices() {
      try {
        console.log('üîÑ Starting to fetch pool prices...');
        console.log('üìä Debug: Contract addresses being used:', {
          YES_POOL: POOL_CONFIG_YES.address,
          NO_POOL: POOL_CONFIG_NO.address,
          SDAI_RATE_PROVIDER: CONTRACT_ADDRESSES.sdaiRateProvider,
          WXDAI: CONTRACT_ADDRESSES.wxdai
        });
        showMessage('price-message', 'Fetching latest prices...', 'info');
        
        // Show loading indicator
        const loadingIndicator = document.getElementById('price-loading');
        if (loadingIndicator) {
          loadingIndicator.style.display = 'block';
        }
        
        // Get provider
        console.log('üîÑ Creating provider with URL: https://rpc.ankr.com/gnosis');
        const provider = new ethers.providers.JsonRpcProvider("https://rpc.ankr.com/gnosis");
        console.log('‚úÖ Provider created successfully:', provider);
        
        // Create contract instances
        console.log('üîÑ Creating YES pool contract with address:', POOL_CONFIG_YES.address);
        const yesPoolContract = new ethers.Contract(
          getChecksumAddress(POOL_CONFIG_YES.address),
          UNISWAP_V3_POOL_ABI,
          provider
        );
        console.log('‚úÖ YES pool contract created successfully');
        
        console.log('üîÑ Creating NO pool contract with address:', POOL_CONFIG_NO.address);
        const noPoolContract = new ethers.Contract(
          getChecksumAddress(POOL_CONFIG_NO.address),
          UNISWAP_V3_POOL_ABI,
          provider
        );
        console.log('‚úÖ NO pool contract created successfully');
        console.log('üîÑ Pool contracts created');
        
        // Fetch each piece of data separately with error handling
        let yesSlot0, noSlot0, sdaiPrice, currencyPrices;
        let debugData = {
          yesSlot0: null,
          noSlot0: null,
          sdaiPrice: null,
          currencyPrices: null,
          calculations: {}
        };
        
        try {
          console.log('üîÑ Fetching YES pool slot0...');
          yesSlot0 = await yesPoolContract.slot0();
          console.log('‚úÖ YES pool slot0 fetched:', yesSlot0);
          debugData.yesSlot0 = {
            sqrtPriceX96: yesSlot0.sqrtPriceX96.toString(),
            tick: yesSlot0.tick.toString()
          };
        } catch (error) {
          console.error('‚ùå Error fetching YES pool slot0:', error);
          console.error('‚ùå Error details:', {
            message: error.message,
            code: error.code,
            stack: error.stack
          });
          yesSlot0 = null;
        }
        
        try {
          console.log('üîÑ Fetching NO pool slot0...');
          noSlot0 = await noPoolContract.slot0();
          console.log('‚úÖ NO pool slot0 fetched:', noSlot0);
          debugData.noSlot0 = {
            sqrtPriceX96: noSlot0.sqrtPriceX96.toString(),
            tick: noSlot0.tick.toString()
          };
        } catch (error) {
          console.error('‚ùå Error fetching NO pool slot0:', error);
          console.error('‚ùå Error details:', {
            message: error.message,
            code: error.code,
            stack: error.stack
          });
          noSlot0 = null;
        }
        
        try {
          console.log('üîÑ Fetching SDAI price...');
          console.log('üìä Debug: About to call fetchSdaiPrice()');
          sdaiPrice = await fetchSdaiPrice();
          console.log('‚úÖ SDAI price fetched:', sdaiPrice);
          debugData.sdaiPrice = sdaiPrice;
        } catch (error) {
          console.error('‚ùå Error fetching SDAI price:', error);
          console.error('‚ùå Error details:', {
            message: error.message,
            code: error.code,
            stack: error.stack
          });
          sdaiPrice = null;
        }
        
        try {
          console.log('üîÑ Fetching currency prices in XDAI...');
          console.log('üìä Debug: About to call fetchCurrencyPricesInXdai()');
          currencyPrices = await fetchCurrencyPricesInXdai();
          console.log('‚úÖ Currency prices fetched:', currencyPrices);
          debugData.currencyPrices = currencyPrices;
        } catch (error) {
          console.error('‚ùå Error fetching currency prices:', error);
          console.error('‚ùå Error details:', {
            message: error.message,
            code: error.code,
            stack: error.stack
          });
          currencyPrices = { yesCurrencyInXdai: null, noCurrencyInXdai: null };
        }
        
        // Calculate prices
        let yesCompanyPrice = null;
        let noCompanyPrice = null;
        
        if (yesSlot0 && yesSlot0.sqrtPriceX96) {
          console.log('üîÑ Calculating YES company price...');
          const sqrtPriceStr = ethers.utils.formatUnits(yesSlot0.sqrtPriceX96, 0);
          console.log('üìä Debug: sqrtPriceStr =', sqrtPriceStr);
          const sqrtPrice = parseFloat(sqrtPriceStr);
          console.log('üìä Debug: sqrtPrice =', sqrtPrice);
          const rawPrice = (sqrtPrice * sqrtPrice) / 2**192;
          console.log('üìä Debug: rawPrice =', rawPrice);
          yesCompanyPrice = POOL_CONFIG_YES.tokenCompanySlot === 1 ? 1 / rawPrice : rawPrice;
          
          console.log('‚úÖ YES company price calculated:', yesCompanyPrice);
          debugData.calculations.yesCompanyPrice = {
            sqrtPriceStr,
            sqrtPrice,
            rawPrice,
            tokenCompanySlot: POOL_CONFIG_YES.tokenCompanySlot,
            finalPrice: yesCompanyPrice
          };
        }
        
        if (noSlot0 && noSlot0.sqrtPriceX96) {
          console.log('üîÑ Calculating NO company price...');
          const sqrtPriceStr = ethers.utils.formatUnits(noSlot0.sqrtPriceX96, 0);
          console.log('üìä Debug: sqrtPriceStr =', sqrtPriceStr);
          const sqrtPrice = parseFloat(sqrtPriceStr);
          console.log('üìä Debug: sqrtPrice =', sqrtPrice);
          const rawPrice = (sqrtPrice * sqrtPrice) / 2**192;
          console.log('üìä Debug: rawPrice =', rawPrice);
          noCompanyPrice = POOL_CONFIG_NO.tokenCompanySlot === 1 ? 1 / rawPrice : rawPrice;
          
          console.log('‚úÖ NO company price calculated:', noCompanyPrice);
          debugData.calculations.noCompanyPrice = {
            sqrtPriceStr,
            sqrtPrice,
            rawPrice,
            tokenCompanySlot: POOL_CONFIG_NO.tokenCompanySlot,
            finalPrice: noCompanyPrice
          };
        }
        
        // Calculate event probability based on YES currency price and SDAI rate
        let eventProbability = null;
        if (currencyPrices.yesCurrencyInXdai && sdaiPrice) {
          console.log('üîÑ Calculating event probability...');
          console.log('üìä Debug: yesCurrencyInXdai =', currencyPrices.yesCurrencyInXdai);
          console.log('üìä Debug: sdaiPrice =', sdaiPrice);
          // Calculate probability as YES / SDAI rate
          eventProbability = currencyPrices.yesCurrencyInXdai / sdaiPrice;
          console.log('üìä Debug: raw eventProbability =', eventProbability);
          // Ensure probability is between 0 and 1
          eventProbability = Math.max(0, Math.min(1, eventProbability));
          console.log('‚úÖ Event probability calculated:', eventProbability);
          
          debugData.calculations.eventProbability = {
            yesCurrencyInXdai: currencyPrices.yesCurrencyInXdai,
            sdaiPrice,
            rawProbability: currencyPrices.yesCurrencyInXdai / sdaiPrice,
            clampedProbability: eventProbability
          };
        }
        
        // Update debug raw data
        console.log('üîÑ Updating debug raw data with:', debugData);
        updateDebugRawData(debugData);
        
        // Update UI with new prices
        console.log('üîÑ Updating price display with:', {
          yesCompanyPrice,
          noCompanyPrice,
          sdaiPrice,
          yesCurrencyInXdai: currencyPrices.yesCurrencyInXdai,
          noCurrencyInXdai: currencyPrices.noCurrencyInXdai,
          eventProbability
        });
        
        updatePriceDisplay({
          yesCompanyPrice,
          noCompanyPrice,
          sdaiPrice,
          yesCurrencyInXdai: currencyPrices.yesCurrencyInXdai,
          noCurrencyInXdai: currencyPrices.noCurrencyInXdai,
          eventProbability
        });
        
        showMessage('price-message', 'Prices updated successfully', 'success');
        console.log('‚úÖ Price fetching completed successfully');
        
        // Hide loading indicator
        if (loadingIndicator) {
          loadingIndicator.style.display = 'none';
        }
        
        return { 
          yesCompanyPrice, 
          noCompanyPrice, 
          sdaiPrice,
          yesCurrencyInXdai: currencyPrices.yesCurrencyInXdai,
          noCurrencyInXdai: currencyPrices.noCurrencyInXdai,
          eventProbability
        };
      } catch (error) {
        console.error('‚ùå Error in fetchPoolPrices:', error);
        console.error('‚ùå Detailed error information:', {
          message: error.message,
          code: error.code,
          stack: error.stack
        });
        showMessage('price-message', `Error fetching prices: ${error.message}`, 'error');
        
        // Hide loading indicator
        const loadingIndicator = document.getElementById('price-loading');
        if (loadingIndicator) {
          loadingIndicator.style.display = 'none';
        }
        
        // Update UI with error message
        updatePriceDisplay({
          yesCompanyPrice: null,
          noCompanyPrice: null,
          sdaiPrice: null,
          yesCurrencyInXdai: null,
          noCurrencyInXdai: null,
          eventProbability: null
        });
        
        // Show error message in the price section
        const priceMessage = document.getElementById('price-message');
        if (priceMessage) {
          priceMessage.innerHTML = `
            <div class="error-message">
              <p>Failed to fetch prices. Please try again later.</p>
              <p>Error: ${error.message}</p>
            </div>
          `;
        }
        
        return { 
          yesCompanyPrice: null, 
          noCompanyPrice: null, 
          sdaiPrice: null,
          yesCurrencyInXdai: null,
          noCurrencyInXdai: null,
          eventProbability: null
        };
      }
    }
    
    /**
     * Update the price display UI with the latest prices
     */
    function updatePriceDisplay(prices) {
      console.log('üîÑ updatePriceDisplay called with prices:', prices);
      
      const formatPrice = (price) => {
        if (price === null || price === undefined) return 'N/A';
        
        // Special handling for very small numbers (like SDAI price)
        if (price < 0.000001) {
          return price.toExponential(6); // Use scientific notation for very small numbers
        }
        
        // Format with 6 decimal places and add commas for thousands
        return new Intl.NumberFormat('en-US', { 
          minimumFractionDigits: 6, 
          maximumFractionDigits: 6 
        }).format(price);
      };
      
      const formatProbability = (probability) => {
        if (probability === null || probability === undefined) return 'N/A';
        // Format as percentage with 2 decimal places
        return new Intl.NumberFormat('en-US', { 
          style: 'percent', 
          minimumFractionDigits: 2, 
          maximumFractionDigits: 2 
        }).format(probability);
      };
      
      // Check if elements exist before updating
      console.log('üîç Checking UI elements before updating:');
      const elementIds = [
        'yes-company-price', 
        'no-company-price', 
        'yes-currency-price', 
        'no-currency-price', 
        'sdai-price', 
        'event-probability', 
        'last-updated'
      ];
      
      const elementStatus = {};
      elementIds.forEach(id => {
        const element = document.getElementById(id);
        elementStatus[id] = element ? 'Found' : 'Missing';
      });
      console.log('üîç UI element status:', elementStatus);
      
      // Update the UI elements if they exist
      if (elements.yesCompanyPrice) {
        elements.yesCompanyPrice.textContent = formatPrice(prices.yesCompanyPrice);
        console.log('‚úÖ Updated YES company price to:', elements.yesCompanyPrice.textContent);
      } else {
        console.error('‚ùå Could not find YES company price element');
      }
      
      if (elements.noCompanyPrice) {
        elements.noCompanyPrice.textContent = formatPrice(prices.noCompanyPrice);
        console.log('‚úÖ Updated NO company price to:', elements.noCompanyPrice.textContent);
      } else {
        console.error('‚ùå Could not find NO company price element');
      }
      
      if (elements.yesCurrencyPrice) {
        elements.yesCurrencyPrice.textContent = formatPrice(prices.yesCurrencyInXdai);
        console.log('‚úÖ Updated YES currency price to:', elements.yesCurrencyPrice.textContent);
      } else {
        console.error('‚ùå Could not find YES currency price element');
      }
      
      if (elements.noCurrencyPrice) {
        elements.noCurrencyPrice.textContent = formatPrice(prices.noCurrencyInXdai);
        console.log('‚úÖ Updated NO currency price to:', elements.noCurrencyPrice.textContent);
      } else {
        console.error('‚ùå Could not find NO currency price element');
      }
      
      if (elements.sdaiPrice) {
        // Special formatting for SDAI price to make it more readable
        if (prices.sdaiPrice !== null && prices.sdaiPrice !== undefined) {
          // Format SDAI price with more precision
          elements.sdaiPrice.textContent = prices.sdaiPrice.toFixed(8);
          // Add a tooltip with the full value
          elements.sdaiPrice.title = `Full value: ${prices.sdaiPrice}`;
        } else {
          elements.sdaiPrice.textContent = 'N/A';
        }
        console.log('‚úÖ Updated SDAI price to:', elements.sdaiPrice.textContent);
      } else {
        console.error('‚ùå Could not find SDAI price element');
      }
      
      if (elements.eventProbability) {
        elements.eventProbability.textContent = formatProbability(prices.eventProbability);
        console.log('‚úÖ Updated event probability to:', elements.eventProbability.textContent);
      } else {
        console.error('‚ùå Could not find event probability element');
      }
      
      if (elements.lastUpdated) {
        elements.lastUpdated.textContent = new Date().toLocaleString();
        console.log('‚úÖ Updated last updated timestamp to:', elements.lastUpdated.textContent);
      } else {
        console.error('‚ùå Could not find last updated element');
      }
    }

    // Main application code
    document.addEventListener('DOMContentLoaded', async function() {
      console.log('üîÑ DOMContentLoaded event fired');
      
      // Initialize debug information
      initializeDebugInfo();
      
      // Check if debug mode is enabled
      const urlParams = new URLSearchParams(window.location.search);
      if (urlParams.has('debug')) {
        const debugButtonContainer = document.getElementById('debug-button-container');
        if (debugButtonContainer) {
          debugButtonContainer.style.display = 'block';
          
          // Add click event listener to the debug button
          const debugButton = document.getElementById('debug-button');
          if (debugButton) {
            debugButton.addEventListener('click', function() {
              console.log('Debug button clicked, running debug function...');
             // debugSwapBalance();
            });
          }
        }
      }
      
      // Check if MetaMask is installed
      if (window.ethereum) {
        try {
          // Check if already connected
          const accounts = await window.ethereum.request({ method: 'eth_accounts' });
          if (accounts.length > 0) {
            // User is already connected
            await connectWallet();
          }
        } catch (error) {
          console.error('Error checking connection:', error);
        }
      } else {
        showMessage('connection-message', 'MetaMask is not installed', 'error');
      }
      
      try {
        // Set up event listeners for the swap section
        setupSwapEventListeners();
      } catch (error) {
        console.error('Error setting up swap event listeners:', error);
      }
      
      // Update the swap balance display
      console.log('üîÑ DOMContentLoaded event, updating swap balance display');
      try {
        updateAvailableBalanceForSwap();
      } catch (error) {
        console.error('Error updating available balance for swap:', error);
      }
      
      // Fetch initial prices
      console.log('üîÑ Fetching initial market prices');
      try {
        fetchPoolPrices();
      } catch (error) {
        console.error('Error fetching initial market prices:', error);
        showMessage('price-message', `Error fetching prices: ${error.message}`, 'error');
      }
    });

    /**
     * Test the slot0 function on the Uniswap V3 Pool contract
     */
    async function testSlot0Function() {
      try {
        console.log('üîÑ Testing slot0 function...');
        
        // Create provider
        console.log('üîÑ Creating provider...');
        const provider = new ethers.providers.JsonRpcProvider("https://rpc.ankr.com/gnosis");
        console.log('‚úÖ Provider created successfully');
        
        // Create contract instance for YES pool
        console.log('üîÑ Creating YES pool contract with address:', POOL_CONFIG_YES.address);
        const yesPoolContract = new ethers.Contract(
          getChecksumAddress(POOL_CONFIG_YES.address),
          UNISWAP_V3_POOL_ABI,
          provider
        );
        console.log('‚úÖ YES pool contract created successfully');
        
        // Test slot0 function
        console.log('üîÑ Calling slot0 function on YES pool...');
        const slot0 = await yesPoolContract.slot0();
        console.log('‚úÖ slot0 function called successfully');
        console.log('üìä slot0 result:', {
          sqrtPriceX96: slot0.sqrtPriceX96.toString(),
          tick: slot0.tick.toString(),
          observationIndex: slot0.observationIndex.toString(),
          observationCardinality: slot0.observationCardinality.toString(),
          observationCardinalityNext: slot0.observationCardinalityNext.toString(),
          feeProtocol: slot0.feeProtocol.toString(),
          unlocked: slot0.unlocked
        });
        
        // Calculate price
        const sqrtPriceStr = ethers.utils.formatUnits(slot0.sqrtPriceX96, 0);
        const sqrtPrice = parseFloat(sqrtPriceStr);
        const rawPrice = (sqrtPrice * sqrtPrice) / 2**192;
        const price = POOL_CONFIG_YES.tokenCompanySlot === 1 ? 1 / rawPrice : rawPrice;
        
        console.log('üìä Calculated price:', price);
        
        return {
          success: true,
          slot0: slot0,
          price: price
        };
      } catch (error) {
        console.error('‚ùå Error testing slot0 function:', error);
        console.error('‚ùå Error details:', {
          message: error.message,
          code: error.code,
          stack: error.stack
        });
        
        return {
          success: false,
          error: error
        };
      }
    }

    /**
     * Verify contract addresses and test if they're valid
     */
    async function verifyContractAddresses() {
      try {
        console.log('üîÑ Verifying contract addresses...');
        
        // Create provider
        console.log('üîÑ Creating provider...');
        const provider = new ethers.providers.JsonRpcProvider("https://rpc.ankr.com/gnosis");
        console.log('‚úÖ Provider created successfully');
        
        // Check if addresses match
        console.log('üìä Checking if addresses match:');
        console.log('CONTRACT_ADDRESSES.poolYes:', CONTRACT_ADDRESSES.poolYes);
        console.log('POOL_CONFIG_YES.address:', POOL_CONFIG_YES.address);
        console.log('Addresses match:', CONTRACT_ADDRESSES.poolYes === POOL_CONFIG_YES.address);
        
        console.log('CONTRACT_ADDRESSES.poolNo:', CONTRACT_ADDRESSES.poolNo);
        console.log('POOL_CONFIG_NO.address:', POOL_CONFIG_NO.address);
        console.log('Addresses match:', CONTRACT_ADDRESSES.poolNo === POOL_CONFIG_NO.address);
        
        // Verify YES pool contract code exists
        console.log('üîÑ Verifying YES pool contract code...');
        const yesPoolCode = await provider.getCode(getChecksumAddress(POOL_CONFIG_YES.address));
        console.log('YES pool code length:', yesPoolCode.length);
        console.log('YES pool has code:', yesPoolCode !== '0x');
        
        // Verify NO pool contract code exists
        console.log('üîÑ Verifying NO pool contract code...');
        const noPoolCode = await provider.getCode(getChecksumAddress(POOL_CONFIG_NO.address));
        console.log('NO pool code length:', noPoolCode.length);
        console.log('NO pool has code:', noPoolCode !== '0x');
        
        return {
          success: true,
          addressesMatch: {
            poolYes: CONTRACT_ADDRESSES.poolYes === POOL_CONFIG_YES.address,
            poolNo: CONTRACT_ADDRESSES.poolNo === POOL_CONFIG_NO.address
          },
          contractsValid: {
            poolYes: yesPoolCode !== '0x',
            poolNo: noPoolCode !== '0x'
          }
        };
      } catch (error) {
        console.error('‚ùå Error verifying contract addresses:', error);
        return {
          success: false,
          error: error
        };
      }
    }

    // Debug prices button
    const debugPricesButton = document.getElementById('debug-prices');
    if (debugPricesButton) {
      debugPricesButton.addEventListener('click', async function() {
        console.log('üîç Debug Prices button clicked');
        
        try {
          // Show a message that we're starting debug
          showMessage('price-message', 'Starting price debug process...', 'info');
          
          // Check if ethers.js is loaded
          console.log('üîç Checking if ethers.js is loaded:', typeof ethers !== 'undefined' ? 'YES' : 'NO');
          
          // Check contract addresses
          console.log('üîç Contract addresses:', {
            YES_POOL: POOL_CONFIG_YES.address,
            NO_POOL: POOL_CONFIG_NO.address,
            SDAI_RATE_PROVIDER: CONTRACT_ADDRESSES.sdaiRateProvider,
            WXDAI: CONTRACT_ADDRESSES.wxdai,
            YES_SDAI: CONTRACT_ADDRESSES.yes_sdai,
            NO_SDAI: CONTRACT_ADDRESSES.no_sdai
          });
          
          // Test RPC connection
          console.log('üîç Testing RPC connection...');
          try {
            const provider = new ethers.providers.JsonRpcProvider("https://rpc.ankr.com/gnosis");
            const blockNumber = await provider.getBlockNumber();
            console.log('‚úÖ RPC connection successful! Current block number:', blockNumber);
          } catch (error) {
            console.error('‚ùå RPC connection failed:', error);
            showMessage('price-message', `RPC connection failed: ${error.message}`, 'error');
            return;
          }
          
          // Test SDAI rate provider contract
          console.log('üîç Testing SDAI rate provider contract...');
          try {
            const provider = new ethers.providers.JsonRpcProvider("https://rpc.ankr.com/gnosis");
            const sdaiRateProviderAbi = ["function getRate() external view returns (uint256)"];
            const sdaiRateProviderContract = new ethers.Contract(
              CONTRACT_ADDRESSES.sdaiRateProvider,
              sdaiRateProviderAbi,
              provider
            );
            const sdaiRate = await sdaiRateProviderContract.getRate();
            console.log('‚úÖ SDAI rate provider contract working! Rate:', sdaiRate.toString());
          } catch (error) {
            console.error('‚ùå SDAI rate provider contract failed:', error);
            showMessage('price-message', `SDAI rate provider failed: ${error.message}`, 'error');
            return;
          }
          
          // Test slot0 function
          console.log('üîç Testing slot0 function...');
          try {
            const slot0 = await testSlot0Function();
            console.log('‚úÖ slot0 function test passed!');
          } catch (error) {
            console.error('‚ùå slot0 function test failed:', error);
            showMessage('price-message', `slot0 function test failed: ${error.message}`, 'error');
            return;
          }
          
          // If all tests pass, try fetching prices
          console.log('üîç All tests passed! Attempting to fetch prices...');
          showMessage('price-message', 'All tests passed! Fetching prices...', 'info');
          
          // Call the fetchPoolPrices function
          await fetchPoolPrices();
          
        } catch (error) {
          console.error('‚ùå Debug process failed:', error);
          showMessage('price-message', `Debug process failed: ${error.message}`, 'error');
        }
      });
    }

    // Add click event listener to the debug button
    const debugButton = document.getElementById('debug-button');
    if (debugButton) {
      debugButton.addEventListener('click', async function() {
        console.log('Debug button clicked, running debug functions...');
        
        // Check if ethers.js is available
        if (typeof ethers === 'undefined') {
          console.error('‚ùå ethers.js is not available');
          return;
        }
        console.log('‚úÖ ethers.js is available');
        
        // Check if contract addresses are available
        console.log('üìä Contract addresses:', {
          YES_POOL: POOL_CONFIG_YES.address,
          NO_POOL: POOL_CONFIG_NO.address,
          SDAI_RATE_PROVIDER: CONTRACT_ADDRESSES.sdaiRateProvider,
          WXDAI: CONTRACT_ADDRESSES.wxdai,
          YES_SDAI: CONTRACT_ADDRESSES.yes_sdai,
          NO_SDAI: CONTRACT_ADDRESSES.no_sdai
        });
        
        // Test RPC connection
        try {
          console.log('üîÑ Testing RPC connection...');
          const provider = new ethers.providers.JsonRpcProvider("https://rpc.ankr.com/gnosis");
          const blockNumber = await provider.getBlockNumber();
          console.log('‚úÖ RPC connection successful, current block number:', blockNumber);
        } catch (error) {
          console.error('‚ùå RPC connection failed:', error);
        }
        
        // Test SDAI rate provider contract
        try {
          console.log('üîÑ Testing SDAI rate provider contract...');
          const sdaiResult = await fetchSdaiPrice();
          console.log('‚úÖ SDAI rate provider contract test successful, rate:', sdaiResult);
        } catch (error) {
          console.error('‚ùå SDAI rate provider contract test failed:', error);
        }
        
        // Test slot0 function
        try {
          console.log('üîÑ Testing slot0 function...');
          const slot0Result = await testSlot0Function();
          console.log('‚úÖ slot0 function test result:', slot0Result);
        } catch (error) {
          console.error('‚ùå slot0 function test failed:', error);
        }
        
        // Fetch prices if all tests pass
        try {
          console.log('üîÑ Fetching prices...');
          await fetchPoolPrices();
          console.log('‚úÖ Price fetching completed');
        } catch (error) {
          console.error('‚ùå Price fetching failed:', error);
        }
      });
    }

    /**
     * Get the selected token type (currency or company)
     * @returns {string} The selected token type ('currency' or 'company')
     */
    function getSelectedTokenType() {
      const currencyRadio = document.getElementById('currency-token-type');
      const companyRadio = document.getElementById('company-token-type');
      
      if (currencyRadio && currencyRadio.checked) {
        return 'currency';
      } else if (companyRadio && companyRadio.checked) {
        return 'company';
      }
      
      // Default to currency if no selection is found
      console.warn('No token type selected, defaulting to currency');
      return 'currency';
    }

    /**
     * Handle MAX button click - sets the maximum amount based on the available balance
     */
    function handleSetMax() {
      console.log('MAX button clicked - setting maximum amount');
      
      // Check if the swap amount input exists
      if (!elements.swapAmount) {
        console.warn('Swap amount input not found');
        return;
      }
      
      // Get the available balance from the UI
      const availableBalanceElement = document.getElementById('available-balance-amount');
      if (!availableBalanceElement) {
        console.warn('Available balance element not found');
        return;
      }
      
      // Get the available balance value
      const availableBalance = availableBalanceElement.textContent;
      if (!availableBalance || isNaN(parseFloat(availableBalance))) {
        console.warn('Invalid available balance:', availableBalance);
        return;
      }
      
      // Set the input value to the available balance
      elements.swapAmount.value = availableBalance;
      
      console.log('Set maximum amount to available balance:', availableBalance);
    }
  </script>
</body>
</html> 